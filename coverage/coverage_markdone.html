
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>db: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/remiges-tech/crux/db/error.go (0.0%)</option>
				
				<option value="file1">github.com/remiges-tech/crux/db/pg.go (75.0%)</option>
				
				<option value="file2">github.com/remiges-tech/crux/db/sqlc-gen/app.sql.go (0.0%)</option>
				
				<option value="file3">github.com/remiges-tech/crux/db/sqlc-gen/capgrant.sql.go (0.0%)</option>
				
				<option value="file4">github.com/remiges-tech/crux/db/sqlc-gen/config.sql.go (0.0%)</option>
				
				<option value="file5">github.com/remiges-tech/crux/db/sqlc-gen/db.go (100.0%)</option>
				
				<option value="file6">github.com/remiges-tech/crux/db/sqlc-gen/deactivated.sql.go (0.0%)</option>
				
				<option value="file7">github.com/remiges-tech/crux/db/sqlc-gen/models.go (23.1%)</option>
				
				<option value="file8">github.com/remiges-tech/crux/db/sqlc-gen/realmslice.sql.go (0.0%)</option>
				
				<option value="file9">github.com/remiges-tech/crux/db/sqlc-gen/ruleset.sql.go (5.9%)</option>
				
				<option value="file10">github.com/remiges-tech/crux/db/sqlc-gen/schema.sql.go (12.7%)</option>
				
				<option value="file11">github.com/remiges-tech/crux/db/sqlc-gen/sqlc_tx.go (0.0%)</option>
				
				<option value="file12">github.com/remiges-tech/crux/db/sqlc-gen/stepworkflow.sql.go (100.0%)</option>
				
				<option value="file13">github.com/remiges-tech/crux/db/sqlc-gen/wfinstance.sql.go (32.0%)</option>
				
				<option value="file14">github.com/remiges-tech/crux/matching-engine/cache.go (66.0%)</option>
				
				<option value="file15">github.com/remiges-tech/crux/matching-engine/collect_actions.go (68.2%)</option>
				
				<option value="file16">github.com/remiges-tech/crux/matching-engine/do_match.go (31.0%)</option>
				
				<option value="file17">github.com/remiges-tech/crux/matching-engine/match_pattern.go (33.9%)</option>
				
				<option value="file18">github.com/remiges-tech/crux/matching-engine/verify_data.go (5.6%)</option>
				
				<option value="file19">github.com/remiges-tech/crux/server/markdone/markdone.go (54.4%)</option>
				
				<option value="file20">github.com/remiges-tech/crux/server/markdone/markdoneutils.go (76.0%)</option>
				
				<option value="file21">github.com/remiges-tech/crux/server/markdone/markdonewsc.go (66.0%)</option>
				
				<option value="file22">github.com/remiges-tech/crux/server/wfinstance/wfinstance_abort.go (0.0%)</option>
				
				<option value="file23">github.com/remiges-tech/crux/server/wfinstance/wfinstance_list.go (0.0%)</option>
				
				<option value="file24">github.com/remiges-tech/crux/server/wfinstance/wfinstance_new.go (0.0%)</option>
				
				<option value="file25">github.com/remiges-tech/crux/server/wfinstance/wfinstancenew_add.go (81.2%)</option>
				
				<option value="file26">github.com/remiges-tech/crux/server/wfinstance/wfinstancenew_validation.go (0.0%)</option>
				
				<option value="file27">github.com/remiges-tech/crux/server/wfinstance/wfinstanceutils.go (0.0%)</option>
				
				<option value="file28">github.com/remiges-tech/crux/server/wsc_utils.go (3.0%)</option>
				
				<option value="file29">github.com/remiges-tech/crux/testutils/test_utils.go (25.0%)</option>
				
				<option value="file30">github.com/remiges-tech/crux/types/types.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package db

import (
        "errors"

        "github.com/jackc/pgx/v5/pgconn"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/server"
)

// The function HandleDatabaseError first checks if the error is a PostgreSQL-specific error
//
//        by attempting to cast it to a *pgconn.PgError. If successful, it examines the PostgreSQL
//        error code to determine the nature of the error.If none of the above conditions are met,
//        it constructs a generic error message indicating an internal server error related to
//
// the database.
func HandleDatabaseError(err error) wscutils.ErrorMessage <span class="cov0" title="0">{
        var pgErr *pgconn.PgError

        if errors.As(err, &amp;pgErr) </span><span class="cov0" title="0">{
                switch pgErr.Code </span>{
                case "23505":<span class="cov0" title="0"> //unique_violation
                        return wscutils.BuildErrorMessage(server.MsgId_Invalid_Request, server.ErrCode_AlreadyExist, &amp;pgErr.ConstraintName)</span>
                case "23503":<span class="cov0" title="0"> //foreign_key_violation
                        return wscutils.BuildErrorMessage(server.MsgId_Invalid_Request, server.ErrCode_NotFound, &amp;pgErr.ConstraintName)</span>
                case "23502":<span class="cov0" title="0"> //not_null_violation
                        return wscutils.BuildErrorMessage(server.MsgId_Invalid_Request, server.ErrCode_Invalid, &amp;pgErr.ColumnName)</span>
                case "0A000":<span class="cov0" title="0"> //ERROR: cached plan must not change result type (SQLSTATE 0A000)
                        return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_Internal_Retry, nil)</span>
                case "XX000":<span class="cov0" title="0"> //ERROR: cache lookup failed for type 67119 (SQLSTATE XX000)
                        return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_Internal_Retry, nil)</span>
                case "42P01":<span class="cov0" title="0"> //ERROR: relation \"&lt;field&gt;\" does not exist (SQLSTATE 42P01)
                        return wscutils.BuildErrorMessage(server.MsgId_NotFound, server.ErrCode_NotExist, nil)</span>
                default:<span class="cov0" title="0">
                        return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_DatabaseError, nil)</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "no rows in result set" </span><span class="cov0" title="0">{
                        // field := "slice/app/class"
                        return wscutils.BuildErrorMessage(server.MsgId_Invalid_Request, server.ErrCode_No_record_Found, nil)
                }</span> else<span class="cov0" title="0"> {
                        return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_DatabaseError, nil)
                }</span>
        } else<span class="cov0" title="0"> {
                return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_DatabaseError, nil)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package db

import (
        "context"

        "github.com/jackc/pgx/v5/pgxpool"
)

func NewProvider(connString string) (*pgxpool.Pool, error) <span class="cov8" title="1">{
        ctx := context.Background()
        connPool, err := pgxpool.New(ctx, connString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = connPool.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return connPool, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: app.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const appDelete = `-- name: AppDelete :exec
DELETE FROM app
WHERE shortnamelc = $1 AND realm = $2
`

type AppDeleteParams struct {
        Shortnamelc string `json:"shortnamelc"`
        Realm       string `json:"realm"`
}

func (q *Queries) AppDelete(ctx context.Context, arg AppDeleteParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, appDelete, arg.Shortnamelc, arg.Realm)
        return err
}</span>

const appExist = `-- name: AppExist :one
SELECT
    CASE
        WHEN EXISTS (SELECT 1 FROM schema WHERE schema.app = $1) OR
             EXISTS (SELECT 1 FROM ruleset WHERE ruleset.app = $1)
        THEN 1
        ELSE 0
    END AS value_exists
`

func (q *Queries) AppExist(ctx context.Context, app string) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, appExist, app)
        var value_exists int32
        err := row.Scan(&amp;value_exists)
        return value_exists, err
}</span>

const appNew = `-- name: AppNew :many
INSERT INTO
    app (
        realm, shortname, shortnamelc, longname, setby
    )
VALUES (
        $1, $2, $3, $4, $5
    )
RETURNING
    id, realm, shortname, shortnamelc, longname, setby, setat
`

type AppNewParams struct {
        Realm       string `json:"realm"`
        Shortname   string `json:"shortname"`
        Shortnamelc string `json:"shortnamelc"`
        Longname    string `json:"longname"`
        Setby       string `json:"setby"`
}

func (q *Queries) AppNew(ctx context.Context, arg AppNewParams) ([]App, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, appNew,
                arg.Realm,
                arg.Shortname,
                arg.Shortnamelc,
                arg.Longname,
                arg.Setby,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []App
        for rows.Next() </span><span class="cov0" title="0">{
                var i App
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.Shortname,
                        &amp;i.Shortnamelc,
                        &amp;i.Longname,
                        &amp;i.Setby,
                        &amp;i.Setat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const appUpdate = `-- name: AppUpdate :exec
UPDATE app
set
    longname = $1,
    setat = NOW(),
    setby = $2
WHERE
    shortnamelc = $3
    AND realm = $4
`

type AppUpdateParams struct {
        Longname    string `json:"longname"`
        Setby       string `json:"setby"`
        Shortnamelc string `json:"shortnamelc"`
        Realm       string `json:"realm"`
}

func (q *Queries) AppUpdate(ctx context.Context, arg AppUpdateParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, appUpdate,
                arg.Longname,
                arg.Setby,
                arg.Shortnamelc,
                arg.Realm,
        )
        return err
}</span>

const getAppList = `-- name: GetAppList :many
SELECT
    a.shortnamelc AS name,
    a.longname AS descr,
    a.setat AS createdat,
    a.setby AS createdby,
    ( SELECT COUNT(DISTINCT "user")
        FROM capgrant
        WHERE app = a.shortnamelc
    ) AS nusers,
    ( SELECT COUNT(*)
        FROM ruleset
        WHERE app = a.shortnamelc AND brwf = 'B'
    ) AS nrulesetsbre,
    ( SELECT COUNT(*)
        FROM ruleset
        WHERE app = a.shortnamelc AND brwf = 'W'
    ) AS nrulesetswfe
FROM
    app a
WHERE
a.realm= $1
`

type GetAppListRow struct {
        Name         string           `json:"name"`
        Descr        string           `json:"descr"`
        Createdat    pgtype.Timestamp `json:"createdat"`
        Createdby    string           `json:"createdby"`
        Nusers       int64            `json:"nusers"`
        Nrulesetsbre int64            `json:"nrulesetsbre"`
        Nrulesetswfe int64            `json:"nrulesetswfe"`
}

func (q *Queries) GetAppList(ctx context.Context, realm string) ([]GetAppListRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAppList, realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []GetAppListRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetAppListRow
                if err := rows.Scan(
                        &amp;i.Name,
                        &amp;i.Descr,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Nusers,
                        &amp;i.Nrulesetsbre,
                        &amp;i.Nrulesetswfe,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getAppName = `-- name: GetAppName :many
select id, realm, shortname, shortnamelc, longname, setby, setat FROM app WHERE shortnamelc = $1 AND realm = $2
`

type GetAppNameParams struct {
        Shortnamelc string `json:"shortnamelc"`
        Realm       string `json:"realm"`
}

func (q *Queries) GetAppName(ctx context.Context, arg GetAppNameParams) ([]App, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAppName, arg.Shortnamelc, arg.Realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []App
        for rows.Next() </span><span class="cov0" title="0">{
                var i App
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.Shortname,
                        &amp;i.Shortnamelc,
                        &amp;i.Longname,
                        &amp;i.Setby,
                        &amp;i.Setat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getAppNames = `-- name: GetAppNames :many
SELECT shortnamelc FROM app WHERE realm = $1
`

func (q *Queries) GetAppNames(ctx context.Context, realm string) ([]string, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAppNames, realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []string
        for rows.Next() </span><span class="cov0" title="0">{
                var shortnamelc string
                if err := rows.Scan(&amp;shortnamelc); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, shortnamelc)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: capgrant.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgtype"
)

const appExists = `-- name: AppExists :one
SELECT count(*)
FROM capgrant
WHERE $1::text []
`

func (q *Queries) AppExists(ctx context.Context, app []string) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, appExists, app)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const capExists = `-- name: CapExists :one
SELECT count(*)
FROM capgrant
WHERE $1::text []
`

func (q *Queries) CapExists(ctx context.Context, cap []string) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, capExists, cap)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const capGet = `-- name: CapGet :many
SELECT app,cap,setby,setat,"from","to" from capgrant WHERE realm = $1 and "user" = $2
`

type CapGetParams struct {
        Realm  string `json:"realm"`
        Userid string `json:"userid"`
}

type CapGetRow struct {
        App   pgtype.Text      `json:"app"`
        Cap   string           `json:"cap"`
        Setby string           `json:"setby"`
        Setat pgtype.Timestamp `json:"setat"`
        From  pgtype.Timestamp `json:"from"`
        To    pgtype.Timestamp `json:"to"`
}

func (q *Queries) CapGet(ctx context.Context, arg CapGetParams) ([]CapGetRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, capGet, arg.Realm, arg.Userid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []CapGetRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i CapGetRow
                if err := rows.Scan(
                        &amp;i.App,
                        &amp;i.Cap,
                        &amp;i.Setby,
                        &amp;i.Setat,
                        &amp;i.From,
                        &amp;i.To,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const capList = `-- name: CapList :many
SELECT "user",app,cap,"from","to",setat,setby from capgrant
WHERE realm = $1
and (($2::text[] is null) OR ( app = any($2::text[])))
and (($3::text[] is null) OR ( cap = any($3::text[])))
`

type CapListParams struct {
        Realm string   `json:"realm"`
        App   []string `json:"app"`
        Cap   []string `json:"cap"`
}

type CapListRow struct {
        User  string           `json:"user"`
        App   pgtype.Text      `json:"app"`
        Cap   string           `json:"cap"`
        From  pgtype.Timestamp `json:"from"`
        To    pgtype.Timestamp `json:"to"`
        Setat pgtype.Timestamp `json:"setat"`
        Setby string           `json:"setby"`
}

func (q *Queries) CapList(ctx context.Context, arg CapListParams) ([]CapListRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, capList, arg.Realm, arg.App, arg.Cap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []CapListRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i CapListRow
                if err := rows.Scan(
                        &amp;i.User,
                        &amp;i.App,
                        &amp;i.Cap,
                        &amp;i.From,
                        &amp;i.To,
                        &amp;i.Setat,
                        &amp;i.Setby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const capRevoke = `-- name: CapRevoke :execresult
DELETE FROM capgrant 
WHERE (($2::text [] is null) OR (capgrant.cap = any ($2::text [])))
AND (($3::text [] is null) OR (capgrant.app = any ($3::text [])))
AND capgrant.user = $1
`

type CapRevokeParams struct {
        User string   `json:"user"`
        Cap  []string `json:"cap"`
        App  []string `json:"app"`
}

func (q *Queries) CapRevoke(ctx context.Context, arg CapRevokeParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, capRevoke, arg.User, arg.Cap, arg.App)
}</span>

const countOfRootCapUser = `-- name: CountOfRootCapUser :one
SELECT count(1)
FROM capgrant
WHERE cap = 'root'
`

func (q *Queries) CountOfRootCapUser(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countOfRootCapUser)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const deleteCapGranForApp = `-- name: DeleteCapGranForApp :exec

DELETE FROM capgrant WHERE app = $1 AND realm = $2 AND "user" = $3
`

type DeleteCapGranForAppParams struct {
        App    pgtype.Text `json:"app"`
        Realm  string      `json:"realm"`
        Userid string      `json:"userid"`
}

func (q *Queries) DeleteCapGranForApp(ctx context.Context, arg DeleteCapGranForAppParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteCapGranForApp, arg.App, arg.Realm, arg.Userid)
        return err
}</span>

const getCapGrantForApp = `-- name: GetCapGrantForApp :many

SELECT id, realm, "user", app, cap, "from", "to", setat, setby FROM capgrant WHERE app = $1 AND realm = $2 AND "user" = $3
`

type GetCapGrantForAppParams struct {
        App    pgtype.Text `json:"app"`
        Realm  string      `json:"realm"`
        Userid string      `json:"userid"`
}

func (q *Queries) GetCapGrantForApp(ctx context.Context, arg GetCapGrantForAppParams) ([]Capgrant, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getCapGrantForApp, arg.App, arg.Realm, arg.Userid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Capgrant
        for rows.Next() </span><span class="cov0" title="0">{
                var i Capgrant
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.User,
                        &amp;i.App,
                        &amp;i.Cap,
                        &amp;i.From,
                        &amp;i.To,
                        &amp;i.Setat,
                        &amp;i.Setby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getCapGrantForUser = `-- name: GetCapGrantForUser :many
DELETE FROM capgrant  WHERE "user" = $1 AND realm = $2 RETURNING id, realm, "user", app, cap, "from", "to", setat, setby
`

type GetCapGrantForUserParams struct {
        Userid string `json:"userid"`
        Realm  string `json:"realm"`
}

func (q *Queries) GetCapGrantForUser(ctx context.Context, arg GetCapGrantForUserParams) ([]Capgrant, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getCapGrantForUser, arg.Userid, arg.Realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Capgrant
        for rows.Next() </span><span class="cov0" title="0">{
                var i Capgrant
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.User,
                        &amp;i.App,
                        &amp;i.Cap,
                        &amp;i.From,
                        &amp;i.To,
                        &amp;i.Setat,
                        &amp;i.Setby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getUserCapsAndAppsByRealm = `-- name: GetUserCapsAndAppsByRealm :many
SELECT  cap ,app FROM capgrant  WHERE "user" = $1 and realm = $2 and app= any($3::text[])
`

type GetUserCapsAndAppsByRealmParams struct {
        Userid string   `json:"userid"`
        Realm  string   `json:"realm"`
        App    []string `json:"app"`
}

type GetUserCapsAndAppsByRealmRow struct {
        Cap string      `json:"cap"`
        App pgtype.Text `json:"app"`
}

func (q *Queries) GetUserCapsAndAppsByRealm(ctx context.Context, arg GetUserCapsAndAppsByRealmParams) ([]GetUserCapsAndAppsByRealmRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getUserCapsAndAppsByRealm, arg.Userid, arg.Realm, arg.App)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []GetUserCapsAndAppsByRealmRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetUserCapsAndAppsByRealmRow
                if err := rows.Scan(&amp;i.Cap, &amp;i.App); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getUserCapsByRealm = `-- name: GetUserCapsByRealm :many
SELECT  cap  FROM capgrant  WHERE "user" = $1 and realm = $2
`

type GetUserCapsByRealmParams struct {
        Userid string `json:"userid"`
        Realm  string `json:"realm"`
}

func (q *Queries) GetUserCapsByRealm(ctx context.Context, arg GetUserCapsByRealmParams) ([]string, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getUserCapsByRealm, arg.Userid, arg.Realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []string
        for rows.Next() </span><span class="cov0" title="0">{
                var cap string
                if err := rows.Scan(&amp;cap); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, cap)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getUserRealm = `-- name: GetUserRealm :many
SELECT  realm  FROM capgrant  WHERE "user" = $1
`

func (q *Queries) GetUserRealm(ctx context.Context, userid string) ([]string, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getUserRealm, userid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []string
        for rows.Next() </span><span class="cov0" title="0">{
                var realm string
                if err := rows.Scan(&amp;realm); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, realm)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const grantAppCapability = `-- name: GrantAppCapability :exec
INSERT INTO capgrant (realm, "user", app, cap, "from", "to", setat, setby)
VALUES ($1, $2, $3, $4, $5, $6, NOW() AT TIME ZONE 'UTC', $7)
`

type GrantAppCapabilityParams struct {
        Realm  string           `json:"realm"`
        Userid string           `json:"userid"`
        App    pgtype.Text      `json:"app"`
        Cap    string           `json:"cap"`
        From   pgtype.Timestamp `json:"from"`
        To     pgtype.Timestamp `json:"to"`
        Setby  string           `json:"setby"`
}

func (q *Queries) GrantAppCapability(ctx context.Context, arg GrantAppCapabilityParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, grantAppCapability,
                arg.Realm,
                arg.Userid,
                arg.App,
                arg.Cap,
                arg.From,
                arg.To,
                arg.Setby,
        )
        return err
}</span>

const grantRealmCapability = `-- name: GrantRealmCapability :exec
INSERT INTO capgrant (realm,"user",cap,"from","to",setat,setby)
VALUES($1, $2,unnest($3::text []), $4 ,$5,(NOW() AT TIME ZONE 'UTC'),$6)
`

type GrantRealmCapabilityParams struct {
        Realm  string           `json:"realm"`
        Userid string           `json:"userid"`
        Cap    []string         `json:"cap"`
        From   pgtype.Timestamp `json:"from"`
        To     pgtype.Timestamp `json:"to"`
        Setby  string           `json:"setby"`
}

func (q *Queries) GrantRealmCapability(ctx context.Context, arg GrantRealmCapabilityParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, grantRealmCapability,
                arg.Realm,
                arg.Userid,
                arg.Cap,
                arg.From,
                arg.To,
                arg.Setby,
        )
        return err
}</span>

const revokeCapGrantForUser = `-- name: RevokeCapGrantForUser :exec
DELETE FROM capgrant  WHERE "user" = $1 AND realm = $2
`

type RevokeCapGrantForUserParams struct {
        Userid string `json:"userid"`
        Realm  string `json:"realm"`
}

func (q *Queries) RevokeCapGrantForUser(ctx context.Context, arg RevokeCapGrantForUserParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, revokeCapGrantForUser, arg.Userid, arg.Realm)
        return err
}</span>

const userActivate = `-- name: UserActivate :one
UPDATE capgrant
SET
    "from" = CASE
        WHEN (
            $1::TIMESTAMP
        ) IS NULL THEN NOW()
        ELSE (
            $1::TIMESTAMP
        )
    END,
    "to" = NULL
WHERE
    "user" = $2
    and realm = $3
RETURNING id, realm, "user", app, cap, "from", "to", setat, setby
`

type UserActivateParams struct {
        Activateat pgtype.Timestamp `json:"activateat"`
        Userid     string           `json:"userid"`
        Realm      string           `json:"realm"`
}

func (q *Queries) UserActivate(ctx context.Context, arg UserActivateParams) (Capgrant, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, userActivate, arg.Activateat, arg.Userid, arg.Realm)
        var i Capgrant
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.User,
                &amp;i.App,
                &amp;i.Cap,
                &amp;i.From,
                &amp;i.To,
                &amp;i.Setat,
                &amp;i.Setby,
        )
        return i, err
}</span>

const userDeactivate = `-- name: UserDeactivate :one
UPDATE capgrant
SET
    "to" = CASE
        WHEN (
            $1::TIMESTAMP
        ) IS NULL THEN NOW()
        ELSE (
            $1::TIMESTAMP
        )
    END,
    "from" = NULL
WHERE
    "user" = $2
    and realm = $3
RETURNING id, realm, "user", app, cap, "from", "to", setat, setby
`

type UserDeactivateParams struct {
        Deactivateat pgtype.Timestamp `json:"deactivateat"`
        Userid       string           `json:"userid"`
        Realm        string           `json:"realm"`
}

func (q *Queries) UserDeactivate(ctx context.Context, arg UserDeactivateParams) (Capgrant, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, userDeactivate, arg.Deactivateat, arg.Userid, arg.Realm)
        var i Capgrant
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.User,
                &amp;i.App,
                &amp;i.Cap,
                &amp;i.From,
                &amp;i.To,
                &amp;i.Setat,
                &amp;i.Setby,
        )
        return i, err
}</span>

const userExists = `-- name: UserExists :one
SELECT count(*)
FROM capgrant
WHERE "user" = $1
`

func (q *Queries) UserExists(ctx context.Context, user string) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, userExists, user)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: config.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const configGet = `-- name: ConfigGet :many
SELECT 
name AS attr,
val,ver,
setby AS by
FROM config 
where realm = $1
`

type ConfigGetRow struct {
        Attr string      `json:"attr"`
        Val  pgtype.Text `json:"val"`
        Ver  pgtype.Int4 `json:"ver"`
        By   string      `json:"by"`
}

func (q *Queries) ConfigGet(ctx context.Context, realm string) ([]ConfigGetRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, configGet, realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []ConfigGetRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i ConfigGetRow
                if err := rows.Scan(
                        &amp;i.Attr,
                        &amp;i.Val,
                        &amp;i.Ver,
                        &amp;i.By,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const configSet = `-- name: ConfigSet :exec
INSERT INTO
    config(
        realm, slice, name, descr, val, setby
    )
VALUES (
        $1, $2, $3, $4, $5, $6
    )
`

type ConfigSetParams struct {
        Realm string      `json:"realm"`
        Slice int32       `json:"slice"`
        Name  string      `json:"name"`
        Descr string      `json:"descr"`
        Val   pgtype.Text `json:"val"`
        Setby string      `json:"setby"`
}

func (q *Queries) ConfigSet(ctx context.Context, arg ConfigSetParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, configSet,
                arg.Realm,
                arg.Slice,
                arg.Name,
                arg.Descr,
                arg.Val,
                arg.Setby,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov8" title="1">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: deactivated.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const activateRecord = `-- name: ActivateRecord :exec
DELETE FROM deactivated WHERE realm = $1 and "user"= $2
`

type ActivateRecordParams struct {
        Realm  string      `json:"realm"`
        Userid pgtype.Text `json:"userid"`
}

func (q *Queries) ActivateRecord(ctx context.Context, arg ActivateRecordParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, activateRecord, arg.Realm, arg.Userid)
        return err
}</span>

const deactivateRecord = `-- name: DeactivateRecord :exec
INSERT INTO deactivated (realm , "user", deactby, deactat)
VALUES ($1,$2,$3,$4)
`

type DeactivateRecordParams struct {
        Realm   string           `json:"realm"`
        Userid  pgtype.Text      `json:"userid"`
        Deactby string           `json:"deactby"`
        Deactat pgtype.Timestamp `json:"deactat"`
}

func (q *Queries) DeactivateRecord(ctx context.Context, arg DeactivateRecordParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deactivateRecord,
                arg.Realm,
                arg.Userid,
                arg.Deactby,
                arg.Deactat,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0

package sqlc

import (
        "database/sql/driver"
        "fmt"

        "github.com/jackc/pgx/v5/pgtype"
)

type BrwfEnum string

const (
        BrwfEnumB BrwfEnum = "B"
        BrwfEnumW BrwfEnum = "W"
)

func (e *BrwfEnum) Scan(src interface{}) error <span class="cov8" title="1">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = BrwfEnum(s)</span>
        case string:<span class="cov8" title="1">
                *e = BrwfEnum(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for BrwfEnum: %T", src)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type NullBrwfEnum struct {
        BrwfEnum BrwfEnum `json:"brwf_enum"`
        Valid    bool     `json:"valid"` // Valid is true if BrwfEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBrwfEnum) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.BrwfEnum, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.BrwfEnum.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullBrwfEnum) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.BrwfEnum), nil</span>
}

type App struct {
        ID          int32            `json:"id"`
        Realm       string           `json:"realm"`
        Shortname   string           `json:"shortname"`
        Shortnamelc string           `json:"shortnamelc"`
        Longname    string           `json:"longname"`
        Setby       string           `json:"setby"`
        Setat       pgtype.Timestamp `json:"setat"`
}

type Capgrant struct {
        ID    int32            `json:"id"`
        Realm string           `json:"realm"`
        User  string           `json:"user"`
        App   pgtype.Text      `json:"app"`
        Cap   string           `json:"cap"`
        From  pgtype.Timestamp `json:"from"`
        To    pgtype.Timestamp `json:"to"`
        Setat pgtype.Timestamp `json:"setat"`
        Setby string           `json:"setby"`
}

type Config struct {
        Realm string           `json:"realm"`
        Slice int32            `json:"slice"`
        Name  string           `json:"name"`
        Descr string           `json:"descr"`
        Val   pgtype.Text      `json:"val"`
        Ver   pgtype.Int4      `json:"ver"`
        Setby string           `json:"setby"`
        Setat pgtype.Timestamp `json:"setat"`
}

type Deactivated struct {
        ID      int32            `json:"id"`
        Realm   string           `json:"realm"`
        User    pgtype.Text      `json:"user"`
        Deactby string           `json:"deactby"`
        Deactat pgtype.Timestamp `json:"deactat"`
}

type Realm struct {
        ID          int32            `json:"id"`
        Shortname   string           `json:"shortname"`
        Shortnamelc string           `json:"shortnamelc"`
        Longname    string           `json:"longname"`
        Setby       string           `json:"setby"`
        Setat       pgtype.Timestamp `json:"setat"`
        Payload     []byte           `json:"payload"`
}

type Realmslice struct {
        ID           int32            `json:"id"`
        Realm        string           `json:"realm"`
        Descr        string           `json:"descr"`
        Active       bool             `json:"active"`
        Activateat   pgtype.Timestamp `json:"activateat"`
        Deactivateat pgtype.Timestamp `json:"deactivateat"`
        Createdat    pgtype.Timestamp `json:"createdat"`
        Createdby    string           `json:"createdby"`
        Editedat     pgtype.Timestamp `json:"editedat"`
        Editedby     pgtype.Text      `json:"editedby"`
}

type Ruleset struct {
        ID         int32            `json:"id"`
        Realm      string           `json:"realm"`
        Slice      int32            `json:"slice"`
        App        string           `json:"app"`
        Brwf       BrwfEnum         `json:"brwf"`
        Class      string           `json:"class"`
        Setname    string           `json:"setname"`
        Schemaid   int32            `json:"schemaid"`
        IsActive   pgtype.Bool      `json:"is_active"`
        IsInternal bool             `json:"is_internal"`
        Ruleset    []byte           `json:"ruleset"`
        Createdat  pgtype.Timestamp `json:"createdat"`
        Createdby  string           `json:"createdby"`
        Editedat   pgtype.Timestamp `json:"editedat"`
        Editedby   pgtype.Text      `json:"editedby"`
}

type Schema struct {
        ID            int32            `json:"id"`
        Realm         string           `json:"realm"`
        Slice         int32            `json:"slice"`
        App           string           `json:"app"`
        Brwf          BrwfEnum         `json:"brwf"`
        Class         string           `json:"class"`
        Patternschema []byte           `json:"patternschema"`
        Actionschema  []byte           `json:"actionschema"`
        Createdat     pgtype.Timestamp `json:"createdat"`
        Createdby     string           `json:"createdby"`
        Editedat      pgtype.Timestamp `json:"editedat"`
        Editedby      pgtype.Text      `json:"editedby"`
}

type Stepworkflow struct {
        Slice    int32       `json:"slice"`
        App      pgtype.Text `json:"app"`
        Step     string      `json:"step"`
        Workflow string      `json:"workflow"`
}

type Wfinstance struct {
        ID       int32            `json:"id"`
        Entityid string           `json:"entityid"`
        Slice    int32            `json:"slice"`
        App      string           `json:"app"`
        Class    string           `json:"class"`
        Workflow string           `json:"workflow"`
        Step     string           `json:"step"`
        Loggedat pgtype.Timestamp `json:"loggedat"`
        Doneat   pgtype.Timestamp `json:"doneat"`
        Nextstep string           `json:"nextstep"`
        Parent   pgtype.Int4      `json:"parent"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: realmslice.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgtype"
)

const cloneRecordInConfigBySliceID = `-- name: CloneRecordInConfigBySliceID :execresult
INSERT INTO
    config (
        realm, slice, name, descr, val, ver, setby
    )
SELECT realm, $2, name, descr, val, ver, $3
FROM config
WHERE
    config.slice = $1
`

type CloneRecordInConfigBySliceIDParams struct {
        Slice   int32  `json:"slice"`
        Slice_2 int32  `json:"slice_2"`
        Setby   string `json:"setby"`
}

func (q *Queries) CloneRecordInConfigBySliceID(ctx context.Context, arg CloneRecordInConfigBySliceIDParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, cloneRecordInConfigBySliceID, arg.Slice, arg.Slice_2, arg.Setby)
}</span>

const cloneRecordInRealmSliceBySliceID = `-- name: CloneRecordInRealmSliceBySliceID :one
INSERT INTO
    realmslice (
        realm, descr, active, activateat, deactivateat,createdby
    )
SELECT
    realm,
    COALESCE(
        descr, $4::text
    ),
    true,
    activateat,
    deactivateat,
    $3
FROM realmslice
WHERE
    realmslice.id = $1
    AND realmslice.realm = $2
RETURNING
    realmslice.id
`

type CloneRecordInRealmSliceBySliceIDParams struct {
        ID        int32       `json:"id"`
        Realm     string      `json:"realm"`
        Createdby string      `json:"createdby"`
        Descr     pgtype.Text `json:"descr"`
}

func (q *Queries) CloneRecordInRealmSliceBySliceID(ctx context.Context, arg CloneRecordInRealmSliceBySliceIDParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, cloneRecordInRealmSliceBySliceID,
                arg.ID,
                arg.Realm,
                arg.Createdby,
                arg.Descr,
        )
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const cloneRecordInRulesetBySliceID = `-- name: CloneRecordInRulesetBySliceID :execresult
INSERT INTO
    ruleset (
        realm, slice, app, brwf, class, setname, schemaid, is_active, is_internal, ruleset, createdby
    )
SELECT
    realm,
    $2,
    app,
    brwf,
    class,
    setname,
    schemaid,
    is_active,
    is_internal,
    ruleset,
    $3
FROM ruleset
WHERE
    ruleset.slice = $1
    AND (
        $4::text [] is null
        OR app = any ($4::text [])
    )
`

type CloneRecordInRulesetBySliceIDParams struct {
        Slice     int32    `json:"slice"`
        Slice_2   int32    `json:"slice_2"`
        Createdby string   `json:"createdby"`
        App       []string `json:"app"`
}

func (q *Queries) CloneRecordInRulesetBySliceID(ctx context.Context, arg CloneRecordInRulesetBySliceIDParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, cloneRecordInRulesetBySliceID,
                arg.Slice,
                arg.Slice_2,
                arg.Createdby,
                arg.App,
        )
}</span>

const cloneRecordInSchemaBySliceID = `-- name: CloneRecordInSchemaBySliceID :execresult
INSERT INTO
    schema (
        realm, slice, app, brwf, class, patternschema, actionschema, createdby
    )
SELECT
    realm,
    $2,
    app,
    brwf,
    class,
    patternschema,
    actionschema,
    $3
FROM schema
WHERE
    schema.slice = $1
    AND (
        $4::text [] is null
        OR app = any ($4::text [])
    )
`

type CloneRecordInSchemaBySliceIDParams struct {
        Slice     int32    `json:"slice"`
        Slice_2   int32    `json:"slice_2"`
        Createdby string   `json:"createdby"`
        App       []string `json:"app"`
}

func (q *Queries) CloneRecordInSchemaBySliceID(ctx context.Context, arg CloneRecordInSchemaBySliceIDParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, cloneRecordInSchemaBySliceID,
                arg.Slice,
                arg.Slice_2,
                arg.Createdby,
                arg.App,
        )
}</span>

const getRealmSliceListByRealm = `-- name: GetRealmSliceListByRealm :many
SELECT
    id,descr,active,deactivateat,createdat,createdby,editedat,editedby
FROM
    realmslice
WHERE
    realm= $1
`

type GetRealmSliceListByRealmRow struct {
        ID           int32            `json:"id"`
        Descr        string           `json:"descr"`
        Active       bool             `json:"active"`
        Deactivateat pgtype.Timestamp `json:"deactivateat"`
        Createdat    pgtype.Timestamp `json:"createdat"`
        Createdby    string           `json:"createdby"`
        Editedat     pgtype.Timestamp `json:"editedat"`
        Editedby     pgtype.Text      `json:"editedby"`
}

func (q *Queries) GetRealmSliceListByRealm(ctx context.Context, realm string) ([]GetRealmSliceListByRealmRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getRealmSliceListByRealm, realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []GetRealmSliceListByRealmRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetRealmSliceListByRealmRow
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Descr,
                        &amp;i.Active,
                        &amp;i.Deactivateat,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Editedat,
                        &amp;i.Editedby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const insertNewRecordInRealmSlice = `-- name: InsertNewRecordInRealmSlice :one
INSERT INTO
    realmslice (
        realm, descr, active, createdby
    )
VALUES ($1, $2, true, $3) RETURNING realmslice.id
`

type InsertNewRecordInRealmSliceParams struct {
        Realm     string `json:"realm"`
        Descr     string `json:"descr"`
        Createdby string `json:"createdby"`
}

func (q *Queries) InsertNewRecordInRealmSlice(ctx context.Context, arg InsertNewRecordInRealmSliceParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, insertNewRecordInRealmSlice, arg.Realm, arg.Descr, arg.Createdby)
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const realmSliceActivate = `-- name: RealmSliceActivate :one
UPDATE realmslice
SET
    active = $1,
    activateat = CASE
        WHEN (
            $2::TIMESTAMP
        ) IS NULL THEN NOW()
        ELSE (
            $2::TIMESTAMP
        )
    END,
    deactivateat = NULL
WHERE
    id = $3
RETURNING
    id, realm, descr, active, activateat, deactivateat, createdat, createdby, editedat, editedby
`

type RealmSliceActivateParams struct {
        Isactive   bool             `json:"isactive"`
        Activateat pgtype.Timestamp `json:"activateat"`
        ID         int32            `json:"id"`
}

func (q *Queries) RealmSliceActivate(ctx context.Context, arg RealmSliceActivateParams) (Realmslice, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, realmSliceActivate, arg.Isactive, arg.Activateat, arg.ID)
        var i Realmslice
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.Descr,
                &amp;i.Active,
                &amp;i.Activateat,
                &amp;i.Deactivateat,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const realmSliceAppsList = `-- name: RealmSliceAppsList :many
SELECT a.shortname, a.longname
FROM realmslice
    JOIN app a ON realmslice.realm = a.realm
WHERE
    realmslice.id = $1
`

type RealmSliceAppsListRow struct {
        Shortname string `json:"shortname"`
        Longname  string `json:"longname"`
}

func (q *Queries) RealmSliceAppsList(ctx context.Context, id int32) ([]RealmSliceAppsListRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, realmSliceAppsList, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []RealmSliceAppsListRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i RealmSliceAppsListRow
                if err := rows.Scan(&amp;i.Shortname, &amp;i.Longname); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const realmSliceDeactivate = `-- name: RealmSliceDeactivate :one
UPDATE realmslice
SET
    active = $1,
    deactivateat = CASE
        WHEN (
            $2::TIMESTAMP
        ) IS NULL THEN NOW()
        ELSE (
            $2::TIMESTAMP
        )
    END,
    activateat = NULL
WHERE
    id = $3
RETURNING
    id, realm, descr, active, activateat, deactivateat, createdat, createdby, editedat, editedby
`

type RealmSliceDeactivateParams struct {
        Isactive     bool             `json:"isactive"`
        Deactivateat pgtype.Timestamp `json:"deactivateat"`
        ID           int32            `json:"id"`
}

func (q *Queries) RealmSliceDeactivate(ctx context.Context, arg RealmSliceDeactivateParams) (Realmslice, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, realmSliceDeactivate, arg.Isactive, arg.Deactivateat, arg.ID)
        var i Realmslice
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.Descr,
                &amp;i.Active,
                &amp;i.Activateat,
                &amp;i.Deactivateat,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const realmSlicePurge = `-- name: RealmSlicePurge :execresult
WITH
    del_stepworkflow AS (
        DELETE FROM stepworkflow
    ),
    del_wfinstance AS (
        DELETE FROM wfinstance
    ),
    del_ruleset AS (
        DELETE FROM ruleset
    ),
    del_schema AS (
        DELETE FROM schema
    ),
    del_config AS (
        DELETE FROM config
    )
DELETE FROM realmslice
WHERE
    realmslice.realm = $1
`

func (q *Queries) RealmSlicePurge(ctx context.Context, realm string) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, realmSlicePurge, realm)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: ruleset.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgtype"
)

const allRuleset = `-- name: AllRuleset :many
SELECT
    id, realm, slice, app, brwf, class, setname, schemaid, is_active, is_internal, ruleset, createdat, createdby, editedat, editedby
FROM
    public.ruleset
`

func (q *Queries) AllRuleset(ctx context.Context) ([]Ruleset, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, allRuleset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Ruleset
        for rows.Next() </span><span class="cov0" title="0">{
                var i Ruleset
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Brwf,
                        &amp;i.Class,
                        &amp;i.Setname,
                        &amp;i.Schemaid,
                        &amp;i.IsActive,
                        &amp;i.IsInternal,
                        &amp;i.Ruleset,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Editedat,
                        &amp;i.Editedby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getApp = `-- name: GetApp :one
SELECT app
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND realm = $4
    AND brwf = 'W'
`

type GetAppParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
        Realm string `json:"realm"`
}

func (q *Queries) GetApp(ctx context.Context, arg GetAppParams) (string, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getApp,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
        )
        var app string
        err := row.Scan(&amp;app)
        return app, err
}</span>

const getClass = `-- name: GetClass :one
SELECT class
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND realm = $4
    AND brwf = 'W'
`

type GetClassParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
        Realm string `json:"realm"`
}

func (q *Queries) GetClass(ctx context.Context, arg GetClassParams) (string, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getClass,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
        )
        var class string
        err := row.Scan(&amp;class)
        return class, err
}</span>

const getWFActiveStatus = `-- name: GetWFActiveStatus :one
SELECT is_active
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND realm = $4
    AND brwf = 'W'
    AND setname = $5
`

type GetWFActiveStatusParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Realm   string `json:"realm"`
        Setname string `json:"setname"`
}

func (q *Queries) GetWFActiveStatus(ctx context.Context, arg GetWFActiveStatusParams) (pgtype.Bool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWFActiveStatus,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
                arg.Setname,
        )
        var is_active pgtype.Bool
        err := row.Scan(&amp;is_active)
        return is_active, err
}</span>

const getWFInternalStatus = `-- name: GetWFInternalStatus :one
SELECT is_internal
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND realm = $4
    AND brwf = 'W'
    AND setname = $5
`

type GetWFInternalStatusParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Realm   string `json:"realm"`
        Setname string `json:"setname"`
}

func (q *Queries) GetWFInternalStatus(ctx context.Context, arg GetWFInternalStatusParams) (bool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWFInternalStatus,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
                arg.Setname,
        )
        var is_internal bool
        err := row.Scan(&amp;is_internal)
        return is_internal, err
}</span>

const isWorkflowReferringSchema = `-- name: IsWorkflowReferringSchema :one
select count(*)
From ruleset
Where realm = $1
AND slice = $2
AND app = $3
AND class = $4
AND is_active = true
`

type IsWorkflowReferringSchemaParams struct {
        Realm string `json:"realm"`
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
}

func (q *Queries) IsWorkflowReferringSchema(ctx context.Context, arg IsWorkflowReferringSchemaParams) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, isWorkflowReferringSchema,
                arg.Realm,
                arg.Slice,
                arg.App,
                arg.Class,
        )
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const loadRuleSet = `-- name: LoadRuleSet :one
SELECT id, realm, slice, app, brwf, class, setname, schemaid, is_active, is_internal, ruleset, createdat, createdby, editedat, editedby 
FROM ruleset 
WHERE
     realm = $3::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $4 AND realmslice.realm = $3 )
    AND class = $1
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $5 AND app.realm = $3)
    AND setname = $2
`

type LoadRuleSetParams struct {
        Class     string `json:"class"`
        Setname   string `json:"setname"`
        RealmName string `json:"realm_name"`
        Slice     int32  `json:"slice"`
        App       string `json:"app"`
}

func (q *Queries) LoadRuleSet(ctx context.Context, arg LoadRuleSetParams) (Ruleset, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, loadRuleSet,
                arg.Class,
                arg.Setname,
                arg.RealmName,
                arg.Slice,
                arg.App,
        )
        var i Ruleset
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Brwf,
                &amp;i.Class,
                &amp;i.Setname,
                &amp;i.Schemaid,
                &amp;i.IsActive,
                &amp;i.IsInternal,
                &amp;i.Ruleset,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const rulesetRowLock = `-- name: RulesetRowLock :one
SELECT id, realm, slice, app, brwf, class, setname, schemaid, is_active, is_internal, ruleset, createdat, createdby, editedat, editedby 
FROM ruleset 
WHERE
     realm = $2::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $3 AND realmslice.realm = $2 )
    AND class = $1
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $4 AND app.realm = $2)
FOR UPDATE
`

type RulesetRowLockParams struct {
        Class     string `json:"class"`
        RealmName string `json:"realm_name"`
        Slice     int32  `json:"slice"`
        App       string `json:"app"`
}

func (q *Queries) RulesetRowLock(ctx context.Context, arg RulesetRowLockParams) (Ruleset, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, rulesetRowLock,
                arg.Class,
                arg.RealmName,
                arg.Slice,
                arg.App,
        )
        var i Ruleset
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Brwf,
                &amp;i.Class,
                &amp;i.Setname,
                &amp;i.Schemaid,
                &amp;i.IsActive,
                &amp;i.IsInternal,
                &amp;i.Ruleset,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const workFlowNew = `-- name: WorkFlowNew :one
INSERT INTO
    ruleset (
        realm, slice, app, brwf, class, setname, schemaid, is_active, is_internal, ruleset, createdat, createdby
    )
VALUES (
        $8::varchar,
        (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $9 AND realmslice.realm = $8 ),
        (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $10 AND app.realm = $8), 
        $1, $2, $3, $4, false, $5, $6, CURRENT_TIMESTAMP, $7
    )RETURNING id
`

type WorkFlowNewParams struct {
        Brwf       BrwfEnum `json:"brwf"`
        Class      string   `json:"class"`
        Setname    string   `json:"setname"`
        Schemaid   int32    `json:"schemaid"`
        IsInternal bool     `json:"is_internal"`
        Ruleset    []byte   `json:"ruleset"`
        Createdby  string   `json:"createdby"`
        RealmName  string   `json:"realm_name"`
        Slice      int32    `json:"slice"`
        App        string   `json:"app"`
}

func (q *Queries) WorkFlowNew(ctx context.Context, arg WorkFlowNewParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, workFlowNew,
                arg.Brwf,
                arg.Class,
                arg.Setname,
                arg.Schemaid,
                arg.IsInternal,
                arg.Ruleset,
                arg.Createdby,
                arg.RealmName,
                arg.Slice,
                arg.App,
        )
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const workFlowUpdate = `-- name: WorkFlowUpdate :execresult
UPDATE ruleset
SET
    ruleset = $4,
    editedat = CURRENT_TIMESTAMP,
    editedby = $5
WHERE
    realm = $6::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $7 AND realmslice.realm = $6 )
    AND class = $1
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $8 AND app.realm = $6)
    AND brwf = $2
    AND setname = $3
    AND is_active = false
`

type WorkFlowUpdateParams struct {
        Class     string      `json:"class"`
        Brwf      BrwfEnum    `json:"brwf"`
        Setname   string      `json:"setname"`
        Ruleset   []byte      `json:"ruleset"`
        Editedby  pgtype.Text `json:"editedby"`
        RealmName string      `json:"realm_name"`
        Slice     int32       `json:"slice"`
        App       string      `json:"app"`
}

func (q *Queries) WorkFlowUpdate(ctx context.Context, arg WorkFlowUpdateParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, workFlowUpdate,
                arg.Class,
                arg.Brwf,
                arg.Setname,
                arg.Ruleset,
                arg.Editedby,
                arg.RealmName,
                arg.Slice,
                arg.App,
        )
}</span>

const workflowDelete = `-- name: WorkflowDelete :execresult
DELETE from ruleset
where
    brwf = 'W'
    AND is_active = false
    and slice = $1
    and app = $2
    and class = $3
    and setname = $4
    AND realm = $5
`

type WorkflowDeleteParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Setname string `json:"setname"`
        Realm   string `json:"realm"`
}

func (q *Queries) WorkflowDelete(ctx context.Context, arg WorkflowDeleteParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, workflowDelete,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Setname,
                arg.Realm,
        )
}</span>

const workflowList = `-- name: WorkflowList :many
select
    id,
    slice,
    app,
    class,
    setname as name,
    is_active,
    is_internal,
    createdat,
    createdby,
    editedat,
    editedby
from ruleset
where
    brwf = 'W'
    AND realm = $1
    AND ($2::INTEGER is null OR slice = $2::INTEGER)
    AND ($3::text[] is null OR app = any( $3::text[]))
    AND ($4::text is null OR class = $4::text)
    AND ($5::text is null OR setname = $5::text)
    AND ($6::BOOLEAN is null OR is_active = $6::BOOLEAN)
    AND ($7::BOOLEAN is null OR is_internal = $7::BOOLEAN)
`

type WorkflowListParams struct {
        Realm      string      `json:"realm"`
        Slice      pgtype.Int4 `json:"slice"`
        App        []string    `json:"app"`
        Class      pgtype.Text `json:"class"`
        Setname    pgtype.Text `json:"setname"`
        IsActive   pgtype.Bool `json:"is_active"`
        IsInternal pgtype.Bool `json:"is_internal"`
}

type WorkflowListRow struct {
        ID         int32            `json:"id"`
        Slice      int32            `json:"slice"`
        App        string           `json:"app"`
        Class      string           `json:"class"`
        Name       string           `json:"name"`
        IsActive   pgtype.Bool      `json:"is_active"`
        IsInternal bool             `json:"is_internal"`
        Createdat  pgtype.Timestamp `json:"createdat"`
        Createdby  string           `json:"createdby"`
        Editedat   pgtype.Timestamp `json:"editedat"`
        Editedby   pgtype.Text      `json:"editedby"`
}

func (q *Queries) WorkflowList(ctx context.Context, arg WorkflowListParams) ([]WorkflowListRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, workflowList,
                arg.Realm,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Setname,
                arg.IsActive,
                arg.IsInternal,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []WorkflowListRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i WorkflowListRow
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Name,
                        &amp;i.IsActive,
                        &amp;i.IsInternal,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Editedat,
                        &amp;i.Editedby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const workflowget = `-- name: Workflowget :one
select
    id,
    slice,
    app,
    class,
    setname as name,
    is_active,
    is_internal,
    ruleset as flowrules,
    createdat,
    createdby,
    editedat,
    editedby
from ruleset
where
    slice = $1
    and app = $2
    and class = $3
    and setname = $4
    and realm = $5
    AND brwf = 'W'
`

type WorkflowgetParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Setname string `json:"setname"`
        Realm   string `json:"realm"`
}

type WorkflowgetRow struct {
        ID         int32            `json:"id"`
        Slice      int32            `json:"slice"`
        App        string           `json:"app"`
        Class      string           `json:"class"`
        Name       string           `json:"name"`
        IsActive   pgtype.Bool      `json:"is_active"`
        IsInternal bool             `json:"is_internal"`
        Flowrules  []byte           `json:"flowrules"`
        Createdat  pgtype.Timestamp `json:"createdat"`
        Createdby  string           `json:"createdby"`
        Editedat   pgtype.Timestamp `json:"editedat"`
        Editedby   pgtype.Text      `json:"editedby"`
}

func (q *Queries) Workflowget(ctx context.Context, arg WorkflowgetParams) (WorkflowgetRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, workflowget,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Setname,
                arg.Realm,
        )
        var i WorkflowgetRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Class,
                &amp;i.Name,
                &amp;i.IsActive,
                &amp;i.IsInternal,
                &amp;i.Flowrules,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const ruleExists = `-- name: ruleExists :one
select 1 
from ruleset 
where realm = $1
AND app= $2
AND slice= $3 
AND class = $4
`

type ruleExistsParams struct {
        Realm string `json:"realm"`
        App   string `json:"app"`
        Slice int32  `json:"slice"`
        Class string `json:"class"`
}

func (q *Queries) ruleExists(ctx context.Context, arg ruleExistsParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, ruleExists,
                arg.Realm,
                arg.App,
                arg.Slice,
                arg.Class,
        )
        var column_1 int32
        err := row.Scan(&amp;column_1)
        return column_1, err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: schema.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const allSchemas = `-- name: AllSchemas :many
SELECT id, realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby, editedat, editedby FROM public.schema
`

func (q *Queries) AllSchemas(ctx context.Context) ([]Schema, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, allSchemas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Schema
        for rows.Next() </span><span class="cov0" title="0">{
                var i Schema
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Brwf,
                        &amp;i.Class,
                        &amp;i.Patternschema,
                        &amp;i.Actionschema,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Editedat,
                        &amp;i.Editedby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getSchemaWithLock = `-- name: GetSchemaWithLock :one
SELECT
    id,
    patternschema,
    actionschema,
    editedat,
    editedby
FROM schema
WHERE
    realm = $3::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $4 AND realmslice.realm = $3)
    AND class = $1
    AND brwf =$2
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $5 AND app.realm = $3) FOR
UPDATE
`

type GetSchemaWithLockParams struct {
        Class     string   `json:"class"`
        Brwf      BrwfEnum `json:"brwf"`
        RealmName string   `json:"realm_name"`
        Slice     int32    `json:"slice"`
        App       string   `json:"app"`
}

type GetSchemaWithLockRow struct {
        ID            int32            `json:"id"`
        Patternschema []byte           `json:"patternschema"`
        Actionschema  []byte           `json:"actionschema"`
        Editedat      pgtype.Timestamp `json:"editedat"`
        Editedby      pgtype.Text      `json:"editedby"`
}

func (q *Queries) GetSchemaWithLock(ctx context.Context, arg GetSchemaWithLockParams) (GetSchemaWithLockRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getSchemaWithLock,
                arg.Class,
                arg.Brwf,
                arg.RealmName,
                arg.Slice,
                arg.App,
        )
        var i GetSchemaWithLockRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Patternschema,
                &amp;i.Actionschema,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const loadSchema = `-- name: LoadSchema :many
SELECT id, realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby, editedat, editedby FROM SCHEMA
WHERE realm = $2::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $3 AND realmslice.realm = $2)
    AND class = $1
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $4 AND app.realm = $2)
`

type LoadSchemaParams struct {
        Class     string `json:"class"`
        RealmName string `json:"realm_name"`
        Slice     int32  `json:"slice"`
        App       string `json:"app"`
}

func (q *Queries) LoadSchema(ctx context.Context, arg LoadSchemaParams) ([]Schema, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, loadSchema,
                arg.Class,
                arg.RealmName,
                arg.Slice,
                arg.App,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []Schema
        for rows.Next() </span><span class="cov8" title="1">{
                var i Schema
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Brwf,
                        &amp;i.Class,
                        &amp;i.Patternschema,
                        &amp;i.Actionschema,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Editedat,
                        &amp;i.Editedby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const schemaDelete = `-- name: SchemaDelete :one
DELETE FROM schema WHERE id = $1 RETURNING id
`

func (q *Queries) SchemaDelete(ctx context.Context, id int32) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, schemaDelete, id)
        err := row.Scan(&amp;id)
        return id, err
}</span>

const schemaGet = `-- name: SchemaGet :many
SELECT schema.slice, schema.app, app.longname, schema.class, schema.createdby, schema.createdat, schema.editedby, schema.editedat
FROM schema
    JOIN app ON schema.app = app.shortnamelc
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    schema.realm = $1
    AND schema.slice = $2
    AND schema.class = $3
    AND schema.app = $4
`

type SchemaGetParams struct {
        Realm string `json:"realm"`
        Slice int32  `json:"slice"`
        Class string `json:"class"`
        App   string `json:"app"`
}

type SchemaGetRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaGet(ctx context.Context, arg SchemaGetParams) ([]SchemaGetRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, schemaGet,
                arg.Realm,
                arg.Slice,
                arg.Class,
                arg.App,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []SchemaGetRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i SchemaGetRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const schemaNew = `-- name: SchemaNew :one
INSERT INTO
    schema(
        realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby
    )
VALUES (
        $6::varchar, 
        (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $7 AND realmslice.realm = $6 ), 
        (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $8 AND app.realm = $6), 
        $1, $2, $3, $4, CURRENT_TIMESTAMP, $5
    ) RETURNING id
`

type SchemaNewParams struct {
        Brwf          BrwfEnum `json:"brwf"`
        Class         string   `json:"class"`
        Patternschema []byte   `json:"patternschema"`
        Actionschema  []byte   `json:"actionschema"`
        Createdby     string   `json:"createdby"`
        RealmName     string   `json:"realm_name"`
        Slice         int32    `json:"slice"`
        App           string   `json:"app"`
}

func (q *Queries) SchemaNew(ctx context.Context, arg SchemaNewParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, schemaNew,
                arg.Brwf,
                arg.Class,
                arg.Patternschema,
                arg.Actionschema,
                arg.Createdby,
                arg.RealmName,
                arg.Slice,
                arg.App,
        )
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const schemaUpdate = `-- name: SchemaUpdate :exec
UPDATE schema
SET
    brwf = $2,
    patternschema = COALESCE($3,patternschema),
    actionschema = COALESCE($4,actionschema),
    editedat = CURRENT_TIMESTAMP,
    editedby = $5
WHERE
    realm = $6::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $7 AND realmslice.realm = $6)
    AND class = $1
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $8 AND app.realm = $6)
`

type SchemaUpdateParams struct {
        Class         string      `json:"class"`
        Brwf          BrwfEnum    `json:"brwf"`
        Patternschema []byte      `json:"patternschema"`
        Actionschema  []byte      `json:"actionschema"`
        Editedby      pgtype.Text `json:"editedby"`
        RealmName     string      `json:"realm_name"`
        Slice         int32       `json:"slice"`
        App           string      `json:"app"`
}

func (q *Queries) SchemaUpdate(ctx context.Context, arg SchemaUpdateParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, schemaUpdate,
                arg.Class,
                arg.Brwf,
                arg.Patternschema,
                arg.Actionschema,
                arg.Editedby,
                arg.RealmName,
                arg.Slice,
                arg.App,
        )
        return err
}</span>

const wfPatternSchemaGet = `-- name: WfPatternSchemaGet :one
SELECT patternschema
FROM public.schema
WHERE
    realm = $1
    AND slice = $2
    AND class = $3
    AND app = $4
    AND brwf = 'W'
`

type WfPatternSchemaGetParams struct {
        Realm string `json:"realm"`
        Slice int32  `json:"slice"`
        Class string `json:"class"`
        App   string `json:"app"`
}

func (q *Queries) WfPatternSchemaGet(ctx context.Context, arg WfPatternSchemaGetParams) ([]byte, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, wfPatternSchemaGet,
                arg.Realm,
                arg.Slice,
                arg.Class,
                arg.App,
        )
        var patternschema []byte
        err := row.Scan(&amp;patternschema)
        return patternschema, err
}</span>

const wfSchemaGet = `-- name: WfSchemaGet :one
SELECT id, realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby, editedat, editedby
FROM public.schema
WHERE
    realm = $1
    AND slice = $2
    AND class = $3
    AND app = $4
`

type WfSchemaGetParams struct {
        Realm string `json:"realm"`
        Slice int32  `json:"slice"`
        Class string `json:"class"`
        App   string `json:"app"`
}

func (q *Queries) WfSchemaGet(ctx context.Context, arg WfSchemaGetParams) (Schema, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, wfSchemaGet,
                arg.Realm,
                arg.Slice,
                arg.Class,
                arg.App,
        )
        var i Schema
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Brwf,
                &amp;i.Class,
                &amp;i.Patternschema,
                &amp;i.Actionschema,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const wfSchemaList = `-- name: WfSchemaList :many
SELECT schema.slice, schema.app, app.longname, schema.class, schema.createdby, schema.createdat, schema.editedby, schema.editedat
FROM schema, app, realmslice
where
    schema.app = app.shortnamelc
    and schema.slice = realmslice.id
    AND schema.realm =  $1
    AND schema.brwf = $2
    AND (($3::INTEGER is null) OR (schema.slice = $3::INTEGER))
    AND (($4::text is null) OR (schema.app = $4::text))
    AND ($5::text is null OR schema.class = $5::text)
`

type WfSchemaListParams struct {
        Relam string      `json:"relam"`
        Brwf  BrwfEnum    `json:"brwf"`
        Slice pgtype.Int4 `json:"slice"`
        App   pgtype.Text `json:"app"`
        Class pgtype.Text `json:"class"`
}

type WfSchemaListRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) WfSchemaList(ctx context.Context, arg WfSchemaListParams) ([]WfSchemaListRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, wfSchemaList,
                arg.Relam,
                arg.Brwf,
                arg.Slice,
                arg.App,
                arg.Class,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []WfSchemaListRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i WfSchemaListRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const wfschemadelete = `-- name: Wfschemadelete :exec
DELETE from schema
where
    id in (
        select id
        from (
                SELECT schema.id
                FROM schema, realm, realmslice
                WHERE
                    schema.realm = realm.id
                    and schema.slice = realmslice.id
                    and schema.slice = $1
                    and schema.brwf = $4
                    and realmslice.realm = realm.shortname
                    and schema.realm = $5
                    and schema.class = $3
                    AND schema.app = $2
            ) as id
        where
            id not in(
                SELECT schemaid
                FROM ruleset
                where
                    realm = $5
                    and slice = $1
                    and app = $2
                    and class = $3
                    and brwf = $4
            )
    )
`

type WfschemadeleteParams struct {
        Slice int32    `json:"slice"`
        App   string   `json:"app"`
        Class string   `json:"class"`
        Brwf  BrwfEnum `json:"brwf"`
        Realm string   `json:"realm"`
}

func (q *Queries) Wfschemadelete(ctx context.Context, arg WfschemadeleteParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, wfschemadelete,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Brwf,
                arg.Realm,
        )
        return err
}</span>

const wfschemaget = `-- name: Wfschemaget :one
SELECT s.slice, s.app, s.class, rm.longname, s.patternschema as patternschema, s.actionschema as actionschema, s.createdat, s.createdby, s.editedat, s.editedby
FROM schema as s, realm as rm, realmslice as rs
WHERE
    s.realm = rm.shortname
    and rs.realm = rm.shortname
    and s.slice = rs.id
    and s.slice = $1
    and s.brwf = $4
    and rm.shortname = $5
    and s.class = $3
    AND s.app = $2
`

type WfschemagetParams struct {
        Slice int32    `json:"slice"`
        App   string   `json:"app"`
        Class string   `json:"class"`
        Brwf  BrwfEnum `json:"brwf"`
        Realm string   `json:"realm"`
}

type WfschemagetRow struct {
        Slice         int32            `json:"slice"`
        App           string           `json:"app"`
        Class         string           `json:"class"`
        Longname      string           `json:"longname"`
        Patternschema []byte           `json:"patternschema"`
        Actionschema  []byte           `json:"actionschema"`
        Createdat     pgtype.Timestamp `json:"createdat"`
        Createdby     string           `json:"createdby"`
        Editedat      pgtype.Timestamp `json:"editedat"`
        Editedby      pgtype.Text      `json:"editedby"`
}

func (q *Queries) Wfschemaget(ctx context.Context, arg WfschemagetParams) (WfschemagetRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, wfschemaget,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Brwf,
                arg.Realm,
        )
        var i WfschemagetRow
        err := row.Scan(
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Class,
                &amp;i.Longname,
                &amp;i.Patternschema,
                &amp;i.Actionschema,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package sqlc

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"
)

// DBQuerier defines all functions to execute db queries and transactions
type DBQuerier interface {
        PerformDBOperationWithTX(ctx context.Context, queries func(Querier) (any, error)) (any, error)
        Querier
}

// QuerierTX provides all functions to execute SQL queries and transactions
type QuerierTX struct {
        connPool *pgxpool.Pool
        *Queries
}

/*
NewQuerierWithTX creates a new QuerierTX object
and returns QuerierWithTX interface
*/
func NewQuerierWithTX(connPool *pgxpool.Pool) DBQuerier <span class="cov0" title="0">{
        return &amp;QuerierTX{
                connPool: connPool,
                Queries:  New(connPool),
        }
}</span>

/*
PerformTX performs transaction operations for the queries callbackFunction
methods returns a result and error.PerformTx consist execTX methods which deals
with the transaction commit and rollback logic
*/
func (tx *QuerierTX) PerformDBOperationWithTX(ctx context.Context, queries func(Querier) (any, error)) (any, error) <span class="cov0" title="0">{
        return tx.execTX(ctx, queries)
}</span>

/*
execTX performs transaction commit and rollBack for the seeded
queryCallBack function arguments.execTX will return a result and error Based
on the transaction behavior
*/
func (qtx *QuerierTX) execTX(ctx context.Context, queryCallBack func(Querier) (any, error)) (any, error) <span class="cov0" title="0">{
        tx, err := qtx.connPool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">q := New(tx)
        result, err := queryCallBack(q)
        if err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
                }</span>
                <span class="cov0" title="0">return result, err</span>
        }
        <span class="cov0" title="0">return result, tx.Commit(ctx)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: stepworkflow.sql

package sqlc

import (
        "context"
)

const getWorkflowNameForStep = `-- name: GetWorkflowNameForStep :one
SELECT workflow,step FROM stepworkflow WHERE step = $1
`

type GetWorkflowNameForStepRow struct {
        Workflow string `json:"workflow"`
        Step     string `json:"step"`
}

func (q *Queries) GetWorkflowNameForStep(ctx context.Context, step string) (GetWorkflowNameForStepRow, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getWorkflowNameForStep, step)
        var i GetWorkflowNameForStepRow
        err := row.Scan(&amp;i.Workflow, &amp;i.Step)
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: wfinstance.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const addWFNewInstances = `-- name: AddWFNewInstances :many
INSERT INTO
    wfinstance (
        entityid, slice, app, class, workflow, step, loggedat, nextstep, parent
    )
VALUES (
        $1, $2, $3, $4, $5, unnest($6::text []), (NOW()::timestamp), $7, $8
    )
RETURNING id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent
`

type AddWFNewInstancesParams struct {
        Entityid string      `json:"entityid"`
        Slice    int32       `json:"slice"`
        App      string      `json:"app"`
        Class    string      `json:"class"`
        Workflow string      `json:"workflow"`
        Step     []string    `json:"step"`
        Nextstep string      `json:"nextstep"`
        Parent   pgtype.Int4 `json:"parent"`
}

func (q *Queries) AddWFNewInstances(ctx context.Context, arg AddWFNewInstancesParams) ([]Wfinstance, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, addWFNewInstances,
                arg.Entityid,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Workflow,
                arg.Step,
                arg.Nextstep,
                arg.Parent,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov8" title="1">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const deleteWFInstanceListByParents = `-- name: DeleteWFInstanceListByParents :many
DELETE FROM wfinstance
WHERE 
   ($1::INTEGER[] IS NOT NULL AND id = ANY($1::INTEGER[]) OR $2::INTEGER[] IS NOT NULL AND parent = ANY($2::INTEGER[]))
    RETURNING id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent
`

type DeleteWFInstanceListByParentsParams struct {
        ID     []int32 `json:"id"`
        Parent []int32 `json:"parent"`
}

func (q *Queries) DeleteWFInstanceListByParents(ctx context.Context, arg DeleteWFInstanceListByParentsParams) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, deleteWFInstanceListByParents, arg.ID, arg.Parent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const deleteWFInstances = `-- name: DeleteWFInstances :exec
DELETE FROM
    wfinstance
WHERE
     wfinstance.entityid IN (SELECT wfinstance.entityid FROM wfinstance WHERE wfinstance.id = $1)
    AND wfinstance.slice = $2
    AND wfinstance.app = $3
`

type DeleteWFInstancesParams struct {
        ID    int32  `json:"id"`
        Slice int32  `json:"slice"`
        App   string `json:"app"`
}

func (q *Queries) DeleteWFInstances(ctx context.Context, arg DeleteWFInstancesParams) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteWFInstances, arg.ID, arg.Slice, arg.App)
        return err
}</span>

const deleteWfinstanceByID = `-- name: DeleteWfinstanceByID :many
  DELETE FROM wfinstance
   WHERE
       (id = $1::INTEGER OR entityid = $2::TEXT)
   RETURNING id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent
`

type DeleteWfinstanceByIDParams struct {
        ID       pgtype.Int4 `json:"id"`
        Entityid pgtype.Text `json:"entityid"`
}

func (q *Queries) DeleteWfinstanceByID(ctx context.Context, arg DeleteWfinstanceByIDParams) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, deleteWfinstanceByID, arg.ID, arg.Entityid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getWFINstance = `-- name: GetWFINstance :one
SELECT count(1)
FROM wfinstance
WHERE
    slice = $1
    AND app = $2
    AND workflow = $3
    AND entityid = $4
`

type GetWFINstanceParams struct {
        Slice    int32  `json:"slice"`
        App      string `json:"app"`
        Workflow string `json:"workflow"`
        Entityid string `json:"entityid"`
}

func (q *Queries) GetWFINstance(ctx context.Context, arg GetWFINstanceParams) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWFINstance,
                arg.Slice,
                arg.App,
                arg.Workflow,
                arg.Entityid,
        )
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const getWFInstanceCounts = `-- name: GetWFInstanceCounts :one
SELECT COUNT(*) 
FROM wfinstance
WHERE
    wfinstance.slice = $1
    AND wfinstance.app = $2
    AND wfinstance.workflow = $3
    AND wfinstance.entityid IN (SELECT wfinstance.entityid FROM wfinstance WHERE wfinstance.id = $4)
`

type GetWFInstanceCountsParams struct {
        Slice    int32  `json:"slice"`
        App      string `json:"app"`
        Workflow string `json:"workflow"`
        ID       int32  `json:"id"`
}

func (q *Queries) GetWFInstanceCounts(ctx context.Context, arg GetWFInstanceCountsParams) (int64, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getWFInstanceCounts,
                arg.Slice,
                arg.App,
                arg.Workflow,
                arg.ID,
        )
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const getWFInstanceCurrent = `-- name: GetWFInstanceCurrent :one
 SELECT id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent FROM wfinstance
WHERE
    slice = $1
    AND app = $2
    AND workflow = $3
    AND entityid = $4
`

type GetWFInstanceCurrentParams struct {
        Slice    int32  `json:"slice"`
        App      string `json:"app"`
        Workflow string `json:"workflow"`
        Entityid string `json:"entityid"`
}

func (q *Queries) GetWFInstanceCurrent(ctx context.Context, arg GetWFInstanceCurrentParams) (Wfinstance, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWFInstanceCurrent,
                arg.Slice,
                arg.App,
                arg.Workflow,
                arg.Entityid,
        )
        var i Wfinstance
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Entityid,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Class,
                &amp;i.Workflow,
                &amp;i.Step,
                &amp;i.Loggedat,
                &amp;i.Doneat,
                &amp;i.Nextstep,
                &amp;i.Parent,
        )
        return i, err
}</span>

const getWFInstanceFromId = `-- name: GetWFInstanceFromId :one
SELECT id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent FROM wfinstance 
WHERE 
    id = $1
`

func (q *Queries) GetWFInstanceFromId(ctx context.Context, id int32) (Wfinstance, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getWFInstanceFromId, id)
        var i Wfinstance
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Entityid,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Class,
                &amp;i.Workflow,
                &amp;i.Step,
                &amp;i.Loggedat,
                &amp;i.Doneat,
                &amp;i.Nextstep,
                &amp;i.Parent,
        )
        return i, err
}</span>

const getWFInstanceList = `-- name: GetWFInstanceList :many
SELECT id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent FROM wfinstance
WHERE 
   ($1::INTEGER is null OR slice = $1::INTEGER)
   AND ($2::text is null OR entityid = $2::text)
   AND ($3::text is null OR app = $3::text)
   AND ($4::text is null OR workflow = $4::text)
   AND($5::INTEGER is null OR  parent = $5::INTEGER)
`

type GetWFInstanceListParams struct {
        Slice    pgtype.Int4 `json:"slice"`
        Entityid pgtype.Text `json:"entityid"`
        App      pgtype.Text `json:"app"`
        Workflow pgtype.Text `json:"workflow"`
        Parent   pgtype.Int4 `json:"parent"`
}

func (q *Queries) GetWFInstanceList(ctx context.Context, arg GetWFInstanceListParams) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getWFInstanceList,
                arg.Slice,
                arg.Entityid,
                arg.App,
                arg.Workflow,
                arg.Parent,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getWFInstanceListByParents = `-- name: GetWFInstanceListByParents :many
SELECT id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent FROM wfinstance
WHERE 
   ($1::INTEGER[] IS NOT NULL AND id = ANY($1::INTEGER[]))
`

func (q *Queries) GetWFInstanceListByParents(ctx context.Context, id []int32) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getWFInstanceListByParents, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getWFInstanceListForMarkDone = `-- name: GetWFInstanceListForMarkDone :many
SELECT id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent FROM wfinstance 
WHERE
    wfinstance.slice = $1
    AND wfinstance.app = $2
    AND wfinstance.workflow = $3
    AND wfinstance.entityid IN (SELECT wfinstance.entityid FROM wfinstance WHERE wfinstance.id = $4)
`

type GetWFInstanceListForMarkDoneParams struct {
        Slice    int32  `json:"slice"`
        App      string `json:"app"`
        Workflow string `json:"workflow"`
        ID       int32  `json:"id"`
}

func (q *Queries) GetWFInstanceListForMarkDone(ctx context.Context, arg GetWFInstanceListForMarkDoneParams) ([]Wfinstance, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, getWFInstanceListForMarkDone,
                arg.Slice,
                arg.App,
                arg.Workflow,
                arg.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov8" title="1">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const updateWFInstanceDoneat = `-- name: UpdateWFInstanceDoneat :exec
UPDATE public.wfinstance
SET 
    doneat = $1 -- Set doneat to the provided timestamp
WHERE
    id = $2
    AND slice = $3
    AND app = $4
    AND workflow = $5
`

type UpdateWFInstanceDoneatParams struct {
        Doneat   pgtype.Timestamp `json:"doneat"`
        ID       int32            `json:"id"`
        Slice    int32            `json:"slice"`
        App      string           `json:"app"`
        Workflow string           `json:"workflow"`
}

func (q *Queries) UpdateWFInstanceDoneat(ctx context.Context, arg UpdateWFInstanceDoneatParams) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, updateWFInstanceDoneat,
                arg.Doneat,
                arg.ID,
                arg.Slice,
                arg.App,
                arg.Workflow,
        )
        return err
}</span>

const updateWFInstanceStep = `-- name: UpdateWFInstanceStep :exec
UPDATE public.wfinstance
SET step = $1
WHERE
    id = $2
    AND slice = $3
    AND app = $4
    AND workflow = $5
`

type UpdateWFInstanceStepParams struct {
        Step     string `json:"step"`
        ID       int32  `json:"id"`
        Slice    int32  `json:"slice"`
        App      string `json:"app"`
        Workflow string `json:"workflow"`
}

func (q *Queries) UpdateWFInstanceStep(ctx context.Context, arg UpdateWFInstanceStepParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, updateWFInstanceStep,
                arg.Step,
                arg.ID,
                arg.Slice,
                arg.App,
                arg.Workflow,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package crux

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "time"

        "github.com/remiges-tech/crux/db/sqlc-gen"
)

const (
        BRE = "B"
        WFE = "W"
)

type Cache struct {
        Ctx          context.Context
        Query        *sqlc.Queries
        RulesetCache RulesetCache_t
        SchemaCache  SchemaCache_t
}

func lockCache() <span class="cov8" title="1">{
        cacheLock.Lock()
}</span>

func unlockCache() <span class="cov8" title="1">{
        cacheLock.Unlock()
}</span>

/*
NewCache creates and returns an empty cache instance. The purpose of this function is to ensure that there is
always a single instance of the cache throughout the application's lifecycle.
*/
func NewCache(c context.Context, queries *sqlc.Queries) *Cache <span class="cov8" title="1">{
        return &amp;Cache{
                Ctx:          c,
                Query:        queries,
                RulesetCache: make(RulesetCache_t),
                SchemaCache:  make(SchemaCache_t),
        }
}</span>
func (c Cache) Load(realm, app, class, ruleSetName string, slice int32) error <span class="cov0" title="0">{
        err := c.loadSchema(realm, app, class, slice)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = c.loadRuleSet(realm, app, class, ruleSetName, slice)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (c Cache) loadSchema(realm, app, class string, slice int32) error <span class="cov8" title="1">{
        lockCache()
        defer unlockCache()

        dbResponseSchema, err := c.Query.LoadSchema(context.Background(), sqlc.LoadSchemaParams{
                RealmName: realm,
                Slice:     slice,
                Class:     class,
                App:       app,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(dbResponseSchema) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("schema not found")
        }</span>

        <span class="cov8" title="1">err = c.loadInternalSchema(dbResponseSchema)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c Cache) loadRuleSet(realm, app, class, ruleSetName string, slice int32) error <span class="cov8" title="1">{

        lockCache()
        defer unlockCache()

        dbResponseRuleSet, err := c.Query.LoadRuleSet(c.Ctx,
                sqlc.LoadRuleSetParams{
                        RealmName: realm,
                        Slice:     slice,
                        Class:     class,
                        App:       app,
                        Setname:   ruleSetName,
                })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if IsZeroOfUnderlyingType(dbResponseRuleSet) </span><span class="cov0" title="0">{
                return fmt.Errorf("rule set not found")
        }</span>
        <span class="cov8" title="1">err = c.loadInternalRuleSet(dbResponseRuleSet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c Cache) loadInternal(dbResponseSchema []sqlc.Schema, dbResponseRuleSet sqlc.Ruleset) error <span class="cov0" title="0">{

        err := c.loadInternalSchema(dbResponseSchema)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = c.loadInternalRuleSet(dbResponseRuleSet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c Cache) loadInternalSchema(dbResponseSchema []sqlc.Schema) error <span class="cov8" title="1">{

        if len(dbResponseSchema) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("dbResponseRuleSet is empty")
        }</span>

        <span class="cov8" title="1">for _, row := range dbResponseSchema </span><span class="cov8" title="1">{
                realmKey := Realm_t(string(row.Realm))
                perRealm, exists := c.SchemaCache[realmKey]
                if !exists </span><span class="cov8" title="1">{
                        perRealm = make(PerRealm_t)
                        c.SchemaCache[realmKey] = perRealm
                }</span>

                <span class="cov8" title="1">appKey := App_t(row.App)
                perApp, exists := perRealm[appKey]
                if !exists </span><span class="cov8" title="1">{
                        perApp = make(PerApp_t)
                        perRealm[appKey] = perApp
                }</span>

                <span class="cov8" title="1">sliceKey := Slice_t(row.Slice)
                _, exists = perApp[sliceKey]
                if !exists </span><span class="cov8" title="1">{
                        perApp[sliceKey] = PerSlice_t{
                                LoadedAt: time.Now(),
                                BRSchema: make(map[ClassName_t]Schema_t),
                                WFSchema: make(map[ClassName_t]Schema_t),
                        }
                }</span>
                <span class="cov8" title="1">var patterns []PatternSchema_t

                if err := json.Unmarshal(row.Patternschema, &amp;patterns); err != nil </span><span class="cov0" title="0">{
                        log.Println("Error unmarshaling Patternschema:", err)
                        continue</span>
                }

                <span class="cov8" title="1">var actions ActionSchema_t

                if err := json.Unmarshal(row.Actionschema, &amp;actions); err != nil </span><span class="cov0" title="0">{
                        log.Println("Error parsing ActionSchema JSON:", err)
                        continue</span>
                }

                <span class="cov8" title="1">schemaData := Schema_t{
                        Class:         row.Class,
                        PatternSchema: patterns,
                        ActionSchema:  actions,
                }

                classNameKey := ClassName_t(row.Class)
                if row.Brwf == BRE </span><span class="cov0" title="0">{
                        perApp[sliceKey].BRSchema[classNameKey] = schemaData
                }</span> else<span class="cov8" title="1"> if row.Brwf == WFE </span><span class="cov8" title="1">{
                        perApp[sliceKey].WFSchema[classNameKey] = schemaData
                }</span>

        }
        <span class="cov8" title="1">return nil</span>
}

func (c Cache) loadInternalRuleSet(dbResponseRuleSet sqlc.Ruleset) error <span class="cov8" title="1">{

        if IsZeroOfUnderlyingType(dbResponseRuleSet) </span><span class="cov0" title="0">{
                return fmt.Errorf("didn't get rule set")
        }</span>

        <span class="cov8" title="1">realmKey := Realm_t(string(dbResponseRuleSet.Realm))
        perRealm, exists := c.RulesetCache[realmKey]
        if !exists </span><span class="cov8" title="1">{
                perRealm = make(PerRealm_t)
                c.RulesetCache[realmKey] = perRealm
        }</span>

        <span class="cov8" title="1">appKey := App_t(dbResponseRuleSet.App)
        perApp, exists := perRealm[appKey]
        if !exists </span><span class="cov8" title="1">{
                perApp = make(PerApp_t)
                perRealm[appKey] = perApp
        }</span>

        <span class="cov8" title="1">sliceKey := Slice_t(dbResponseRuleSet.Slice)
        _, exists = perApp[sliceKey]
        if !exists </span><span class="cov8" title="1">{
                perApp[sliceKey] = PerSlice_t{
                        LoadedAt:   time.Now(),
                        BRRulesets: make(map[ClassName_t][]*Ruleset_t),
                        Workflows:  make(map[ClassName_t][]*Ruleset_t),
                }
        }</span>

        <span class="cov8" title="1">var rules []Rule_t
        err := json.Unmarshal(dbResponseRuleSet.Ruleset, &amp;rules)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error unmarshaling rules:", err)
                return nil
        }</span>

        <span class="cov8" title="1">classNameKey := ClassName_t(dbResponseRuleSet.Class)
        newRuleset := &amp;Ruleset_t{
                Id:      dbResponseRuleSet.ID,
                Class:   dbResponseRuleSet.Class,
                SetName: dbResponseRuleSet.Setname,
                Rules:   rules,
        }
        if dbResponseRuleSet.Brwf == BRE </span><span class="cov0" title="0">{
                perApp[sliceKey].BRRulesets[classNameKey] = append(perApp[sliceKey].BRRulesets[classNameKey], newRuleset)

        }</span> else<span class="cov8" title="1"> if dbResponseRuleSet.Brwf == WFE </span><span class="cov8" title="1">{
                fmt.Printf("className: %v", classNameKey)
                fmt.Printf("workflow name: %v", newRuleset.SetName)
                perApp[sliceKey].Workflows[classNameKey] = append(perApp[sliceKey].Workflows[classNameKey], newRuleset)
        }</span>

        // AddReferencesToRuleSetCache()
        <span class="cov8" title="1">return nil</span>
}

// func (c Cache) Purge(brwf, field string) {
//         lockCache()
//         defer unlockCache()

//         if brwf == "B" &amp;&amp; field == "schema" {
//                 SchemaCache[c.Realm][c.App][c.Slice].BRSchema[ClassName_t(c.Class)] = Schema_t{}
//                 RulesetCache[c.Realm][c.App][c.Slice].BRRulesets[c.Class] = nil
//         } else if brwf == "B" &amp;&amp; field == "rule" {
//                 RulesetCache[c.Realm][c.App][c.Slice].BRRulesets[c.Class] = nil
//         } else if brwf == "w" &amp;&amp; field == "schema" {
//                 SchemaCache[c.Realm][c.App][c.Slice].WFSchema[ClassName_t(c.Class)] = Schema_t{}
//                 RulesetCache[c.Realm][c.App][c.Slice].Workflows[c.Class] = nil
//         } else if brwf == "W" &amp;&amp; field == "rule" {
//                 RulesetCache[c.Realm][c.App][c.Slice].Workflows[c.Class] = nil
//         }
// }

// func Reload(ctx context.Context, query sqlc.Querier, slice int32, app, class, realm, workflowName string) error {
//         lockCache()
//         defer unlockCache()
//         if err := purgeInternal(); err != nil {
//                 log.Fatal("Failed to purge data from cache:", err)
//                 return err
//         }
//         // dbResponseSchema, err := query.AllSchemas(ctx)
//         dbResponseSchema, err := query.LoadSchema(ctx, sqlc.LoadSchemaParams{
//                 RealmName: realm,
//                 Slice:     slice,
//                 Class:     class,
//                 App:       app,
//         })
//         if err != nil {
//                 return err
//         }
//         if len(dbResponseSchema) == 0 {
//                 return fmt.Errorf("Didn't get schema")
//         }
//         dbResponseRuleSet, err := query.LoadRuleSet(ctx,
//                 sqlc.LoadRuleSetParams{
//                         Slice:     slice,
//                         App:       app,
//                         Class:     class,
//                         Setname:   workflowName,
//                         RealmName: realm,
//                 })
//         if err != nil {
//                 return err
//         }
//         // if IsZeroOfUnderlyingType(dbResponseRuleSet) {
//         //         return fmt.Errorf("Didn't get rule set")
//         // }
//         err = loadInternal(dbResponseSchema, dbResponseRuleSet)
//         if err != nil {
//                 return err
//         }
//         return nil
// }

func (c Cache) RetriveRuleSchemasAndRuleSetsFromCache(brwf, app, realm, class, ruleSetName string, slice int32) (*Schema_t, *Ruleset_t, error) <span class="cov8" title="1">{

        ruleSchemas, err := c.RetrieveRuleSchemasFromCache(brwf, app, realm, class, slice)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to retrieveRuleSchemasFromCache: %v", err)
        }</span>

        <span class="cov8" title="1">ruleSets, err := c.RetrieveWorkflowRuleSetFromCache(brwf, app, realm, class, ruleSetName, slice)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to RetrieveRuleSetsFromCache: %v", err)
        }</span>

        <span class="cov8" title="1">return ruleSchemas, ruleSets, nil</span>
}

func (c Cache) RetrieveRuleSchemasFromCache(brwf, app, realm, class string, slice int32) (*Schema_t, error) <span class="cov8" title="1">{
        if brwf == BRE </span><span class="cov0" title="0">{
                brSchemas, brExists := c.SchemaCache[Realm_t(realm)][App_t(app)][Slice_t(slice)].BRSchema[ClassName_t(class)]
                if brExists </span><span class="cov0" title="0">{
                        return &amp;brSchemas, nil
                }</span>
                <span class="cov0" title="0">if !brExists </span><span class="cov0" title="0">{
                        if err := c.loadSchema(realm, app, class, slice); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error while loading cache in RetrieveWorkflowRulesetFromCache: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                brSchemas, brExists := c.SchemaCache[Realm_t(realm)][App_t(app)][Slice_t(slice)].BRSchema[ClassName_t(class)]
                                if brExists </span><span class="cov0" title="0">{
                                        return &amp;brSchemas, nil
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, fmt.Errorf("no brschema found")
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> if brwf == WFE </span><span class="cov8" title="1">{
                wfSchemas, wfExists := c.SchemaCache[Realm_t(realm)][App_t(app)][Slice_t(slice)].WFSchema[ClassName_t(class)]
                if wfExists </span><span class="cov8" title="1">{
                        return &amp;wfSchemas, nil
                }</span>
                <span class="cov8" title="1">if !wfExists </span><span class="cov8" title="1">{
                        if err := c.loadSchema(realm, app, class, slice); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error while loading cache in RetrieveWorkflowRulesetFromCache: %v", err)
                        }</span> else<span class="cov8" title="1"> {
                                wfSchemas, wfExists := c.SchemaCache[Realm_t(realm)][App_t(app)][Slice_t(slice)].WFSchema[ClassName_t(class)]
                                if wfExists </span><span class="cov8" title="1">{
                                        return &amp;wfSchemas, nil
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, fmt.Errorf("no wfschema found")
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no schema found")</span>
}

func (c Cache) RetrieveWorkflowRuleSetFromCache(brwf, app, realm, class, ruleSetName string, slice int32) (*Ruleset_t, error) <span class="cov8" title="1">{

        ruleSets, exists := c.getRulesetsFromCacheWithName(brwf, app, realm, class, ruleSetName, slice)
        if exists </span><span class="cov8" title="1">{
                return ruleSets, nil
        }</span> else<span class="cov8" title="1"> {
                if err := c.loadRuleSet(realm, app, class, ruleSetName, slice); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error while loading cache in RetrieveWorkflowRulesetFromCache: %v", err)
                }</span> else<span class="cov8" title="1"> {
                        ruleSets, exists := c.getRulesetsFromCacheWithName(brwf, app, realm, class, ruleSetName, slice)
                        if exists </span><span class="cov8" title="1">{
                                return ruleSets, nil
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("rule set not exist for given specification")
                        }</span>
                }
        }
}

func (c Cache) getRulesetsFromCacheWithName(brwf, app, realm, class, ruleSetName string, slice int32) (*Ruleset_t, bool) <span class="cov8" title="1">{
        if brwf == BRE </span><span class="cov0" title="0">{
                brRulesets, exist := c.RulesetCache[Realm_t(realm)][App_t(app)][Slice_t(slice)].Workflows[ClassName_t(class)]
                if exist </span><span class="cov0" title="0">{
                        for _, r := range brRulesets </span><span class="cov0" title="0">{
                                if r.SetName == ruleSetName </span><span class="cov0" title="0">{
                                        return r, true
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> if brwf == WFE </span><span class="cov8" title="1">{
                workflows, exist := c.RulesetCache[Realm_t(realm)][App_t(app)][Slice_t(slice)].Workflows[ClassName_t(class)]
                if exist </span><span class="cov8" title="1">{
                        for _, w := range workflows </span><span class="cov8" title="1">{
                                if w.SetName == ruleSetName </span><span class="cov8" title="1">{
                                        return w, true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/* This file contains the collectActions() function */

package crux

func collectActions(actionSet ActionSet, ruleActions RuleActionBlock_t) ActionSet <span class="cov8" title="1">{

        newActionSet := ActionSet{
                Tasks:      []string{},
                Properties: make(map[string]string),
        }

        // Union-set of Tasks
        newActionSet.Tasks = append(newActionSet.Tasks, actionSet.Tasks...)
        for _, newTask := range ruleActions.Task </span><span class="cov8" title="1">{
                found := false
                for _, task := range newActionSet.Tasks </span><span class="cov8" title="1">{
                        if newTask == task </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        newActionSet.Tasks = append(newActionSet.Tasks, newTask)
                }</span>
        }

        // Perform "union-set" of Properties, overwriting previous property values if needed

        <span class="cov8" title="1">for name, val := range actionSet.Properties </span><span class="cov0" title="0">{
                newActionSet.Properties[name] = val
        }</span>

        // Update Properties from ruleActions
        <span class="cov8" title="1">for propName, propertyVal := range ruleActions.Properties </span><span class="cov8" title="1">{
                found := false
                for existingPropName := range newActionSet.Properties </span><span class="cov0" title="0">{
                        if existingPropName == propName </span><span class="cov0" title="0">{
                                newActionSet.Properties[existingPropName] = propertyVal
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        newActionSet.Properties[propName] = propertyVal
                }</span>
        }

        <span class="cov8" title="1">return newActionSet</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
This file contains doMatch() and a helper function called by doMatch().

It also contains ruleSchemasCache and ruleSetsCache, two  variables that currently store rule-schemas
and rulesets respectively for the purpose of testing doMatch().
*/

package crux

import (
        "fmt"
)

func DoMatch(entity Entity, ruleset *Ruleset_t, ruleSchemasCache *Schema_t, actionSet ActionSet, seenRuleSets map[string]struct{}) (ActionSet, bool, error) <span class="cov8" title="1">{

        seenRuleSets[ruleset.SetName] = struct{}{}

        for _, rule := range ruleset.Rules </span><span class="cov8" title="1">{

                DoExit := false

                matched, err := matchPattern(entity, rule.RulePatterns, actionSet, ruleSchemasCache)

                if err != nil </span><span class="cov0" title="0">{
                        return ActionSet{
                                Tasks:      []string{},
                                Properties: make(map[string]string),
                        }, false, err
                }</span>

                <span class="cov8" title="1">if matched </span><span class="cov8" title="1">{

                        actionSet = collectActions(actionSet, rule.RuleActions)

                        if len(rule.RuleActions.ThenCall) &gt; 0 </span><span class="cov0" title="0">{

                                // setToCall, exists := findRefRuleSetByName(ruleset, rule.RuleActions.ThenCall)

                                // if !exists {
                                //         return ActionSet{}, false, errors.New("set not found")
                                // }

                                if ruleset.Class != entity.Class </span><span class="cov0" title="0">{
                                        return inconsistentRuleSet(ruleset.SetName, ruleset.SetName, ruleset)
                                }</span>

                                <span class="cov0" title="0">var err error
                                actionSet, DoExit, err = DoMatch(entity, ruleset, ruleSchemasCache, actionSet, seenRuleSets)
                                if err != nil </span><span class="cov0" title="0">{
                                        return ActionSet{
                                                Tasks:      []string{},
                                                Properties: make(map[string]string),
                                        }, false, err
                                }</span>
                        } else<span class="cov8" title="1"> if DoExit || rule.RuleActions.DoExit </span><span class="cov0" title="0">{

                                return actionSet, true, nil
                        }</span> else<span class="cov8" title="1"> if rule.RuleActions.DoReturn </span><span class="cov0" title="0">{

                                delete(seenRuleSets, ruleset.SetName)
                                return actionSet, false, nil
                        }</span> else<span class="cov8" title="1"> if len(rule.RuleActions.ElseCall) &gt; 0 </span><span class="cov0" title="0">{

                                // setToCall, exists := findRefRuleSetByName(ruleSetsCache, rule.RuleActions.ElseCall)
                                // if !exists {
                                //         return ActionSet{}, false, errors.New("set not found")
                                // }

                                if ruleset.Class != entity.Class </span><span class="cov0" title="0">{
                                        return inconsistentRuleSet(ruleset.SetName, ruleset.SetName, ruleset)
                                }</span>

                                <span class="cov0" title="0">var err error
                                actionSet, DoExit, err = DoMatch(entity, ruleset, ruleSchemasCache, actionSet, seenRuleSets)
                                if err != nil </span><span class="cov0" title="0">{
                                        return ActionSet{
                                                Tasks:      []string{},
                                                Properties: make(map[string]string),
                                        }, false, err
                                }</span> else<span class="cov0" title="0"> if DoExit </span><span class="cov0" title="0">{
                                        return actionSet, true, nil
                                }</span>
                        }
                        //return actionSet, false, nil
                }
        }

        <span class="cov8" title="1">delete(seenRuleSets, ruleset.SetName)

        return actionSet, true, nil</span>
}

func findRefRuleSetByName(ruleSets []*Ruleset_t, setName string) (*Ruleset_t, bool) <span class="cov0" title="0">{
        for _, ruleset := range ruleSets </span><span class="cov0" title="0">{
                for _, rule := range ruleset.Rules </span><span class="cov0" title="0">{
                        found := false
                        for _, referRuleset := range rule.RuleActions.References </span><span class="cov0" title="0">{
                                if referRuleset.SetName == setName </span><span class="cov0" title="0">{
                                        rule.NMatched++
                                        return referRuleset, true
                                }</span>
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                rule.NFailed++
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, false</span>
}

func inconsistentRuleSet(calledSetName string, currSetName string, ruleSets *Ruleset_t) (ActionSet, bool, error) <span class="cov0" title="0">{
        return ActionSet{}, false, fmt.Errorf("cannot call ruleset %v from ruleset %v",
                calledSetName, currSetName,
        )
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/* This file contains matchPattern(), and helper functions called by matchPattern() */

package crux

import (
        "errors"
        "fmt"
        "strconv"
        "time"
)

const (
        typeBool  = "bool"
        typeInt   = "int"
        typeFloat = "float"
        typeStr   = "str"
        typeEnum  = "enum"
        typeTS    = "ts"

        timeLayout = "2006-01-02T15:04:05Z"

        opEQ = "eq"
        opNE = "ne"
        opLT = "lt"
        opLE = "le"
        opGT = "gt"
        opGE = "ge"

        trueStr  = "true"
        falseStr = "false"
)

func matchPattern(entity Entity, rulePattern []RulePatternBlock_t, actionSet ActionSet, rSchema *Schema_t) (bool, error) <span class="cov8" title="1">{

        for _, term := range rulePattern </span><span class="cov8" title="1">{
                valType := ""
                entityAttrVal := ""

                // Check whether the attribute name in the pattern term exists in the entity attrs map
                if val, ok := entity.Attrs[term.Attr]; ok </span><span class="cov8" title="1">{

                        entityAttrVal = val
                        valType = getTypeFromSchema(entity.Class, term.Attr, rSchema)
                        incrementStatsSchemaCounterNChecked(entity.Class, rSchema)
                }</span>

                // If the attribute value is still empty, check whether it matches any of the Tasks in the action-set
                <span class="cov8" title="1">if entityAttrVal == "" </span><span class="cov0" title="0">{
                        for _, task := range actionSet.Tasks </span><span class="cov0" title="0">{
                                if task == term.Attr </span><span class="cov0" title="0">{
                                        entityAttrVal = trueStr
                                        valType = typeBool
                                }</span>
                        }
                }

                // If the attribute value is still empty, default to false
                <span class="cov8" title="1">if entityAttrVal == "" </span><span class="cov0" title="0">{
                        entityAttrVal = falseStr
                        valType = typeBool
                }</span>

                <span class="cov8" title="1">termval, _ := convertTermAttrVal(term.Val, valType)
                matched, err := makeComparison(entityAttrVal, termval, valType, term.Op)

                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("error making comparison %w", err)
                }</span>

                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

        }

        <span class="cov8" title="1">return true, nil</span>
}

// Function to convert termAttrVal to the expected type based on valType
func convertTermAttrVal(termAttrVal any, valType string) (interface{}, error) <span class="cov8" title="1">{
        switch valType </span>{
        case typeInt:<span class="cov0" title="0">
                if val, ok := termAttrVal.(string); ok </span><span class="cov0" title="0">{
                        intValue, err := strconv.Atoi(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting termAttrVal to int: %w", err)
                        }</span>
                        <span class="cov0" title="0">return intValue, nil</span>
                }
                <span class="cov0" title="0">return termAttrVal, nil</span>
        case typeFloat:<span class="cov0" title="0">
                if val, ok := termAttrVal.(string); ok </span><span class="cov0" title="0">{
                        floatValue, err := strconv.ParseFloat(val, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting termAttrVal to float64: %w", err)
                        }</span>
                        <span class="cov0" title="0">return floatValue, nil</span>
                }
                <span class="cov0" title="0">return termAttrVal, nil</span>
        case typeBool:<span class="cov8" title="1">
                if val, ok := termAttrVal.(string); ok </span><span class="cov0" title="0">{
                        boolValue, err := strconv.ParseBool(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting termAttrVal to bool: %w", err)
                        }</span>
                        <span class="cov0" title="0">return boolValue, nil</span>
                }
                <span class="cov8" title="1">return termAttrVal, nil</span>
        case typeTS:<span class="cov0" title="0">
                // Assuming termAttrVal is already in the correct type
                return termAttrVal, nil</span>
        case typeStr, typeEnum:<span class="cov8" title="1">
                // Assuming termAttrVal is already in the correct type
                return termAttrVal, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("unsupported valType")</span>
        }
}

func getTypeFromSchema(class string, attrName string, ruleSchema *Schema_t) string <span class="cov8" title="1">{

        if ruleSchema == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if ruleSchema.Class == class </span><span class="cov8" title="1">{
                for _, attrSchema := range ruleSchema.PatternSchema </span><span class="cov8" title="1">{

                        if attrSchema.Attr == attrName </span><span class="cov8" title="1">{

                                return attrSchema.ValType
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// Returns whether or not the comparison represented by {entityAttrVal, op, termAttrVal} is true
// For example, {7, gt (greater than), 5} is true but {3, gt, 5} is false
// Returns whether or not the comparison represented by {entityAttrVal, op, termAttrVal} is true
// For example, {7, gt (greater than), 5} is true but {3, gt, 5} is false
func makeComparison(entityAttrVal string, termAttrVal any, valType string, op string) (bool, error) <span class="cov8" title="1">{
        entityAttrValConv, err := ConvertEntityAttrVal(entityAttrVal, valType)

        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error converting value: %w", err)
        }</span>
        <span class="cov8" title="1">switch op </span>{
        case opEQ:<span class="cov8" title="1">

                if entityAttrValConv != termAttrVal </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return true, nil</span>
        case opNE:<span class="cov0" title="0">
                if entityAttrValConv == termAttrVal </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        }
        <span class="cov0" title="0">orderedTypes := map[string]bool{typeInt: true, typeFloat: true, typeTS: true, typeStr: true}
        if !orderedTypes[valType] </span><span class="cov0" title="0">{
                return false, errors.New("not an ordered type")
        }</span>
        <span class="cov0" title="0">var result int8
        var match bool

        switch op </span>{

        case opLT:<span class="cov0" title="0">
                result, err = compare(entityAttrValConv, termAttrVal)
                match = (result == -1)</span>
        case opLE:<span class="cov0" title="0">
                result, err = compare(entityAttrValConv, termAttrVal)
                match = (result == -1) || (result == 0)</span>
        case opGT:<span class="cov0" title="0">
                result, err = compare(entityAttrValConv, termAttrVal)
                match = (result == 1)</span>
        case opGE:<span class="cov0" title="0">
                result, err = compare(entityAttrValConv, termAttrVal)
                match = (result == 1) || (result == 0)</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error making comparison %w", err)
        }</span>
        <span class="cov0" title="0">return match, nil</span>
}

// The compare function returns:
// 0 if a == b,
// -1 if a &lt; b, or
// 1 if a &gt; b
func compare(a any, b any) (int8, error) <span class="cov0" title="0">{
        if a == b </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">var lessThan bool
        switch a.(type) </span>{
        case bool:<span class="cov0" title="0">
                if a.(bool) == b.(bool) </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
        case int:<span class="cov0" title="0">
                if a.(int) &lt; b.(int) </span><span class="cov0" title="0">{
                        lessThan = true
                }</span>
                <span class="cov0" title="0">if a.(int) == b.(int) </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
        case float64:<span class="cov0" title="0">
                if a.(float64) &lt; b.(float64) </span><span class="cov0" title="0">{
                        lessThan = true
                }</span>
                <span class="cov0" title="0">if a.(float64) == b.(float64) </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
        case string:<span class="cov0" title="0">
                if a.(string) &lt; b.(string) </span><span class="cov0" title="0">{
                        lessThan = true
                }</span>
                <span class="cov0" title="0">if a.(string) == b.(string) </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
        case time.Time:<span class="cov0" title="0">
                if a.(time.Time).Before(b.(time.Time)) </span><span class="cov0" title="0">{
                        lessThan = true
                }</span>
                <span class="cov0" title="0">if a.(time.Time) == b.(time.Time) </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
        default:<span class="cov0" title="0">
                return -2, errors.New("invalid type")</span>
        }
        <span class="cov0" title="0">if lessThan </span><span class="cov0" title="0">{
                return -1, nil
        }</span> else<span class="cov0" title="0"> {
                return 1, nil
        }</span>
}

// Converts the string entityAttrVal to its schema-provided type
func ConvertEntityAttrVal(entityAttrVal string, valType string) (any, error) <span class="cov8" title="1">{

        var entityAttrValConv any
        var err error
        switch valType </span>{
        case typeBool:<span class="cov8" title="1">
                entityAttrValConv, err = strconv.ParseBool(entityAttrVal)</span>
        case typeInt:<span class="cov0" title="0">
                entityAttrValConv, err = strconv.Atoi(entityAttrVal)</span>
        case typeFloat:<span class="cov0" title="0">
                entityAttrValConv, err = strconv.ParseFloat(entityAttrVal, 64)</span>
        case typeStr, typeEnum:<span class="cov8" title="1">
                entityAttrValConv = entityAttrVal</span>
        case typeTS:<span class="cov0" title="0">
                entityAttrValConv, err = time.Parse(timeLayout, entityAttrVal)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return entityAttrValConv, nil</span>
}

func incrementStatsSchemaCounterNChecked(class string, schema *Schema_t) <span class="cov8" title="1">{

        if schema != nil </span><span class="cov8" title="1">{

                if schema.Class == class </span><span class="cov8" title="1">{

                        schema.NChecked++
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
This file contains verifyRuleSchema(), verifyRuleSet(), doReferentialChecks() and verifyEntity(),
and their helper functions
*/

package crux

import (
        "fmt"
        "reflect"
        "regexp"
        "slices"
        "time"
)

const (
        step       = "step"
        stepFailed = "stepfailed"
        start      = "START"
        nextStep   = "nextstep"
        done       = "done"

        cruxIDRegExp = `^[a-z][a-z0-9_]*$`
)

var validTypes = map[string]bool{
        typeBool: true, typeInt: true, typeFloat: true, typeStr: true, typeEnum: true, typeTS: true,
}

var validOps = map[string]bool{
        opEQ: true, opNE: true, opLT: true, opLE: true, opGT: true, opGE: true,
}

type CruxError struct {
        Keyword   string `json:"keyword"`
        FieldName string `json:"fieldName"`
        Messages  string `json:"messages"`
        Vals      string `json:"vals,omitempty"`
}

// Error returns the error message string
func (e CruxError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s: %s: %s: %s", e.Keyword, e.FieldName, e.Vals, e.Messages)
}</span>

// Parameters
// rs RuleSchema: the RuleSchema to be verified
// isWF bool: true if the RuleSchema applies to a workflow, otherwise false
func VerifyRuleSchema(rschema []*Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        for _, rs := range rschema </span><span class="cov0" title="0">{

                if len(rs.Class) == 0 </span><span class="cov0" title="0">{
                        err := CruxError{Keyword: "Empty", FieldName: "class", Messages: "schema class is an empty string"} //fmt.Errorf("schema class is an empty string")
                        errs = append(errs, err)
                }</span>
                <span class="cov0" title="0">if err := VerifyPatternSchema(*rs, isWF); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err...)
                }</span>
                <span class="cov0" title="0">if err := VerifyActionSchema(*rs, isWF); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err...)
                }</span>
        }
        <span class="cov0" title="0">return errs</span>
}

func VerifyPatternSchema(rs Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        if len(rs.PatternSchema) == 0 </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "Empty", FieldName: "patternSchema", Messages: "pattern-schema is empty"} //fmt.Errorf("pattern-schema for %v is empty", rs.Class)
                errs = append(errs, err)
        }</span>
        <span class="cov0" title="0">re := regexp.MustCompile(cruxIDRegExp)
        // Bools needed for workflows only
        stepFound, stepFailedFound := false, false

        for i, attrSchema := range rs.PatternSchema </span><span class="cov0" title="0">{
                i++
                if _, exists := validTypes[attrSchema.ValType]; exists </span>{<span class="cov0" title="0">

                }</span> else<span class="cov0" title="0"> {
                        fieldName := fmt.Sprintf("patternSchema[%d].ValType", i)
                        err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: attrSchema.ValType, Messages: "not a valid value-type"} //fmt.Errorf("%v is not a valid value-type", attrSchema.ValType)
                        errs = append(errs, err)
                }</span>

                <span class="cov0" title="0">if !re.MatchString(attrSchema.Attr) </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("patternSchema[%d].attr", i)
                        err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: attrSchema.Attr, Messages: "attribute name is not a valid CruxID"} //fmt.Errorf("attribute name %v is not a valid CruxID", attrSchema.Attr)
                        errs = append(errs, err)
                }</span> else<span class="cov0" title="0"> if attrSchema.ValType == typeEnum &amp;&amp; len(attrSchema.EnumVals) == 0 </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("patternSchema[%d].Vals", i)
                        err := CruxError{Keyword: "Empty", FieldName: fieldName, Messages: "no valid values for enum"} //fmt.Errorf("no valid values for enum %v", attrSchema.Attr)
                        errs = append(errs, err)
                }</span>
                <span class="cov0" title="0">for val := range attrSchema.EnumVals </span><span class="cov0" title="0">{
                        if !re.MatchString(val) &amp;&amp; val != start </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("patternSchema[%d].Vals", i)
                                err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: val, Messages: "enum value is not a valid CruxID"} //fmt.Errorf("enum value %v is not a valid CruxID", val)
                                errs = append(errs, err)
                        }</span>
                }

                // Workflows only
                <span class="cov0" title="0">if attrSchema.Attr == step &amp;&amp; attrSchema.ValType == typeEnum </span><span class="cov0" title="0">{
                        stepFound = true
                }</span>

                <span class="cov0" title="0">if isWF &amp;&amp; attrSchema.Attr == step &amp;&amp; attrSchema.EnumVals[start] != struct{}{} </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("patternSchema[%d].Vals", i)
                        err := CruxError{Keyword: "NotAllowed", FieldName: fieldName, Vals: "Start", Messages: "workflow schema doesn't allow step=START"} //fmt.Errorf("workflow schema for %v doesn't allow step=START", rs.Class)
                        errs = append(errs, err)
                }</span>
                <span class="cov0" title="0">if attrSchema.Attr == stepFailed &amp;&amp; attrSchema.ValType == typeBool </span><span class="cov0" title="0">{
                        stepFailedFound = true
                }</span>
        }

        // Workflows only
        <span class="cov0" title="0">if isWF &amp;&amp; (!stepFound || !stepFailedFound) </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "Required", FieldName: "attr", Vals: "step/stepfailed", Messages: "necessary attributes absent in schema"} //fmt.Errorf("necessary workflow attributes absent in schema for class %v", rs.Class)
                errs = append(errs, err)
        }</span>

        <span class="cov0" title="0">return errs</span>

}

func VerifyActionSchema(rs Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        re := regexp.MustCompile(cruxIDRegExp)
        if len(rs.ActionSchema.Tasks) == 0 &amp;&amp; len(rs.ActionSchema.Properties) == 0 </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "Empty", FieldName: "Tasks/Properties", Messages: "both tasks and properties are empty in schema"} //fmt.Errorf("both tasks and properties are empty in schema for class %v", rs.Class)
                errs = append(errs, err)
        }</span>
        <span class="cov0" title="0">for i, task := range rs.ActionSchema.Tasks </span><span class="cov0" title="0">{
                i++
                if !re.MatchString(task) </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("actionSchema.Tasks[%d]", i)
                        err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: task, Messages: "task is not a valid CruxID"} // fmt.Errorf("task %v is not a valid CruxID", task)
                        errs = append(errs, err)
                }</span>
        }

        // Workflows only

        <span class="cov0" title="0">if isWF &amp;&amp; len(rs.ActionSchema.Properties) != 2 </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "NotAllowed", FieldName: "properties", Messages: "contain exactly two properties"} // //fmt.Errorf("action-schema for %v does not contain exactly two properties", rs.Class)
                errs = append(errs, err)
        }</span>
        <span class="cov0" title="0">nextStepFound, doneFound := false, false

        for i, propName := range rs.ActionSchema.Properties </span><span class="cov0" title="0">{
                i++
                if !re.MatchString(propName) </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("actionSchema.Properties[%d]", i)
                        err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: propName, Messages: "property name is not a valid CruxID"} //fmt.Errorf("property name %v is not a valid CruxID", propName)
                        errs = append(errs, err)
                }</span> else<span class="cov0" title="0"> if propName == nextStep </span><span class="cov0" title="0">{
                        nextStepFound = true
                }</span> else<span class="cov0" title="0"> if propName == done </span><span class="cov0" title="0">{
                        doneFound = true
                }</span>
        }

        // Workflows only
        <span class="cov0" title="0">if isWF &amp;&amp; (!nextStepFound || !doneFound) </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "NotAllowed", FieldName: "properties", Messages: "does not contain both the properties 'nextstep' and 'done'"} // fmt.Errorf("action-schema for %v does not contain both the properties 'nextstep' and 'done'", rs.Class)
                errs = append(errs, err)
        }</span>

        <span class="cov0" title="0">if isWF &amp;&amp; !reflect.DeepEqual(getTasksMapForWF(rs.ActionSchema.Tasks), getStepAttrVals(rs)) </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "NotAllowed", FieldName: "task", Messages: "action-schema tasks are not the same as valid values for 'step' in pattern-schema"} // fmt.Errorf("action-schema tasks for %v are not the same as valid values for 'step' in pattern-schema", rs.Class)
                errs = append(errs, err)
        }</span>
        <span class="cov0" title="0">return errs</span>
}

func getTasksMapForWF(tasks []string) map[string]struct{} <span class="cov0" title="0">{
        tm := map[string]struct{}{}
        for _, t := range tasks </span><span class="cov0" title="0">{
                tm[t] = struct{}{}
        }</span>
        // To allow comparison with the set of valid values for the 'step' attribute, which includes "START"
        // tm[start] = struct{}{}

        <span class="cov0" title="0">return tm</span>
}

func getStepAttrVals(rs Schema_t) map[string]struct{} <span class="cov0" title="0">{

        for _, ps := range rs.PatternSchema </span><span class="cov0" title="0">{
                if ps.Attr == step </span><span class="cov0" title="0">{

                        return ps.EnumVals
                }</span>
        }
        <span class="cov0" title="0">return nil</span>

}

// Parameters
// rs RuleSet: the RuleSet to be verified
// isWF bool: true if the RuleSet is a workflow, otherwise false
// func verifyRuleSet(entiry Entity, rs *Ruleset_t, isWF bool) []error {
//         var errs []error
//         schema, err := getSchema(entiry, entiry.Class)

//         if err != nil {
//                 errs = append(errs, err)
//         }
//         if err := VerifyRulePatterns(rs, schema, isWF); err != nil {
//                 errs = append(errs, err...)
//         }
//         if err := VerifyRuleActions(rs, schema, isWF); err != nil {
//                 errs = append(errs, err...)
//         }

//         return errs
// }

func VerifyRulePatterns(ruleset *Ruleset_t, schema *Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        for i, rule := range ruleset.Rules </span><span class="cov0" title="0">{
                i++
                for j, term := range rule.RulePatterns </span><span class="cov0" title="0">{
                        j++
                        valType := GetType(schema, term.Attr)

                        if !verifyType(term.Val, valType) </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("rule[%d].term[%d]val", i, j)
                                err := CruxError{Keyword: "NotMatch", FieldName: fieldName, Messages: "value of this attribute does not match schema"} // fmt.Errorf("value of this attribute does not match schema type: %v", term.Attr)
                                errs = append(errs, err)
                        }</span>
                        <span class="cov0" title="0">if !validOps[term.Op] </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("rule[%d].term[%d]op", i, j)
                                err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: term.Op, Messages: "invalid operation in rule"} // fmt.Errorf("invalid operation in rule: %v", term.Op)
                                errs = append(errs, err)
                        }</span>
                }
                // Workflows only
                <span class="cov0" title="0">if isWF </span><span class="cov0" title="0">{
                        stepFound := false
                        for j, term := range rule.RulePatterns </span><span class="cov0" title="0">{
                                if term.Attr == step </span><span class="cov0" title="0">{
                                        str := term.Val.(string)
                                        if str == "start" </span><span class="cov0" title="0">{
                                                stepFound = true
                                                break</span>
                                        } else<span class="cov0" title="0"> if !slices.Contains(schema.ActionSchema.Tasks, str) </span><span class="cov0" title="0">{
                                                fieldName := fmt.Sprintf("rule[%d].term[%d]Attr", i, j)
                                                err := CruxError{Keyword: "NotAllowed", FieldName: fieldName, Vals: str, Messages: "step must be present in schema Pattern or action"}
                                                errs = append(errs, err)
                                        }</span>
                                        <span class="cov0" title="0">stepFound = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !stepFound </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("rule[%d].attr", i)
                                err := CruxError{Keyword: "Required", FieldName: fieldName, Messages: "required one 'step' attribute in a rule in workflow"} // fmt.Errorf("no 'step' attribute found in a rule in workflow %v", ruleset.SetName)
                                errs = append(errs, err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return errs</span>
}

// func getSchema(entity Entity, Class string) (*Schema_t, error) {
//         ruleSchemas, _ := retriveRuleSchemasAndRuleSetsFromCache(entity.Realm, entity.App, entity.Class, entity.Slice)

//         if ruleSchemas == nil {
//                 return nil, fmt.Errorf("no schema found for Class %v", Class)
//         }
//         if Class == ruleSchemas.Class {
//                 return ruleSchemas, nil
//         }

//         return nil, fmt.Errorf("no schema found for Class %v", Class)
// }

func GetType(rs *Schema_t, name string) string <span class="cov8" title="1">{
        for _, as := range rs.PatternSchema </span><span class="cov8" title="1">{
                if as.Attr == name </span><span class="cov8" title="1">{
                        return as.ValType
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func isStringInArray(s string, arr []string) bool <span class="cov0" title="0">{
        for _, a := range arr </span><span class="cov0" title="0">{

                if a == s </span><span class="cov0" title="0">{

                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Returns whether or not the type of "val" is the same as "valType"
func verifyType(val any, valType string) bool <span class="cov0" title="0">{

        var ok bool
        switch valType </span>{
        case typeBool:<span class="cov0" title="0">
                _, ok = val.(bool)</span>
        case typeInt:<span class="cov0" title="0">
                _, ok = val.(int)</span>
        case typeFloat:<span class="cov0" title="0">
                _, ok = val.(float64)</span>
        case typeStr:<span class="cov0" title="0">

                _, ok = val.(string)</span>
        case typeEnum:<span class="cov0" title="0">

                _, ok = val.(string)</span>
        case typeTS:<span class="cov0" title="0">
                s, _ := val.(string)
                _, err := time.Parse(timeLayout, s)
                ok = (err == nil)</span>
        }

        <span class="cov0" title="0">return ok</span>
}

func VerifyRuleActions(ruleset *Ruleset_t, schema *Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        //for _, ruleset := range ruleSets {
        for i, rule := range ruleset.Rules </span><span class="cov0" title="0">{
                i++
                for j, t := range rule.RuleActions.Task </span><span class="cov0" title="0">{
                        j++
                        doRet := rule.RuleActions.DoReturn
                        doExit := rule.RuleActions.DoExit

                        found := false

                        if doRet &amp;&amp; doExit </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("rule[%d].ruleActions[%d]", i, j)
                                err := CruxError{Keyword: "Required", FieldName: fieldName, Messages: "required one of RETURN or EXIT"} // fmt.Errorf("there is a rule with both the RETURN and EXIT instructions in ruleset %v", ruleset.SetName)
                                errs = append(errs, err)
                        }</span>
                        <span class="cov0" title="0">if isStringInArray(t, schema.ActionSchema.Tasks) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("rule[%d].ruleActions[%d].task", i, j)
                                err := CruxError{Keyword: "NotExist", FieldName: fieldName, Messages: "task not found in any action-schema"} // fmt.Errorf("task %v not found in any action-schema", t)
                                errs = append(errs, err)
                        }</span>
                }

                <span class="cov0" title="0">for propName := range rule.RuleActions.Properties </span><span class="cov0" title="0">{
                        found := false

                        if isStringInArray(propName, schema.ActionSchema.Properties) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("rule[%d].property", i)
                                err := CruxError{Keyword: "NotExist", FieldName: fieldName, Messages: "property name not found in any action-schema"} // fmt.Errorf("property name %v not found in any action-schema", propName)
                                errs = append(errs, err)

                        }</span>
                }

                // Workflows only
                <span class="cov0" title="0">if isWF </span><span class="cov0" title="0">{

                        nsFound, doneFound := areNextStepAndDoneInProps(rule.RuleActions.Properties)
                        if !nsFound &amp;&amp; !doneFound </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("rule[%d]", i)
                                err := CruxError{Keyword: "NotAllowed", FieldName: fieldName, Messages: "rule found with neither 'nextstep' nor 'done' in ruleset"} // fmt.Errorf("rule found with neither 'nextstep' nor 'done' in ruleset %v", ruleset.SetName)
                                errs = append(errs, err)
                        }</span>
                        <span class="cov0" title="0">if !doneFound &amp;&amp; len(rule.RuleActions.Task) == 0 </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("rule[%d]", i)
                                err := CruxError{Keyword: "NotExist", FieldName: fieldName, Messages: "no tasks and no 'done=true' in a rule"} // fmt.Errorf("no tasks and no 'done=true' in a rule in ruleset %v", ruleset.SetName)
                                errs = append(errs, err)
                        }</span>
                        // currNS := getNextStep(rule.RuleActions.Properties)
                        // fieldName := fmt.Sprintf("rule[%d].task", i)
                        // if len(currNS) &gt; 0 &amp;&amp; !isStringInArray(currNS, rule.RuleActions.Task) {
                        //         err := CruxError{Keyword: "NotExist", FieldName: fieldName, Messages: "`nextstep` value not found in `tasks` in a rule "} // fmt.Errorf("`nextstep` value not found in `tasks` in a rule in ruleset %v", ruleset.SetName)
                        //         errs = append(errs, err)
                        // }
                }
        }

        <span class="cov0" title="0">return errs</span>
}

func areNextStepAndDoneInProps(props map[string]string) (bool, bool) <span class="cov0" title="0">{
        nsFound, doneFound := false, false
        for name, val := range props </span><span class="cov0" title="0">{

                if name == nextStep </span><span class="cov0" title="0">{
                        nsFound = true
                }</span>
                <span class="cov0" title="0">if name == done &amp;&amp; val == trueStr </span><span class="cov0" title="0">{
                        doneFound = true
                }</span>
        }
        <span class="cov0" title="0">return nsFound, doneFound</span>
}

// func getNextStep(props map[string]string) string {
//         for name, val := range props {
//                 if name == nextStep {
//                         return val
//                 }
//         }
//         return ""
// }

// func doReferentialChecks(e Entity) (bool, error) {
//         _, ruleSets := retriveRuleSchemasAndRuleSetsFromCache(e.Realm, e.App, e.Class, e.Slice)

//         for _, ruleset := range ruleSets {
//                 for _, rule := range ruleset.Rules {

//                         if rule.RuleActions.ThenCall != "" || rule.RuleActions.ElseCall != "" {

//                                 return true, nil
//                         }

//                 }
//         }
//         return true, nil
// }

func VerifyEntity(e Entity, rs *Schema_t) error <span class="cov8" title="1">{

        for attrName, attrVal := range e.Attrs </span><span class="cov8" title="1">{

                t := GetType(rs, attrName)
                if t == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("schema does not contain attribute %v", attrName)
                }</span>
                <span class="cov8" title="1">_, err := ConvertEntityAttrVal(attrVal, t)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("attribute %v in entity has value of wrong type", attrName)
                }</span>
        }
        <span class="cov8" title="1">if len(e.Attrs) != len(rs.PatternSchema) </span><span class="cov0" title="0">{
                return fmt.Errorf("entity does not contain all the attributes in its pattern-schema")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func IsZeroOfUnderlyingType(x interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(x, reflect.Zero(reflect.TypeOf(x)).Interface())
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package markdone

import (
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        crux "github.com/remiges-tech/crux/matching-engine"
        "github.com/remiges-tech/crux/server/wfinstance"
        "github.com/remiges-tech/logharbour/logharbour"

        "github.com/remiges-tech/alya/service"
)

const (
        doneProp = "done"
        WFE      = "W"
)

/*
//
// we first check to see if the previous step failed. If yes, we ask the ruleset
// what to do next -- typically expecting an alternate step or remedial step
//
if stepfailed == true then
set entity.step = the step supplied in the request

            invoke doMatch() with
                        entity = the object received
                        ruleset = the ruleset name retrieved from wfinstance
                        actionset and seenruleset = empty array
            if doMatch() returns a critical error then
                return with the critical error details
            endif
            if actionset.properties.done == true then
                delete the wfinstance record
                return specifying that the workflow is completed
            endif
            if actionset.tasks has more than one task then
                delete the old record from wfinstance and create fresh records, one per task
                return the full set of tasks and their record IDs
            else
                update the old record in wfinstance to set the value of "step" = the task returned
                return the task and other data in response
            endif

endif

//
// we come here knowing that the previous step didn't fail. We can now proceed
// to the next step; the previous step was successful
//
recordcount = count_of(SELECT from wfinstance with matching tuple (slice,app,workflow,entityid))
if recordcount == 1 then

        set entity.step = the step supplied in the request
        invoke doMatch() with
                entity = the object received
                ruleset = the ruleset name retrieved from wfinstance
                actionset and seenrulesets: empty

        if doMatch() returns a critical error then
            return with the critical error details
        endif
        if actionset.properties.done == true then
            delete the wfinstance record
            return specifying that the workflow is completed
        endif
        if actionset.tasks has more than one task then
            delete the old record from wfinstance and create fresh records, one per task
            return the full set of tasks and their record IDs
        else
            update the old record in wfinstance to set the value of "step" to the task returned
            return the task and other data in response
        endif

else (this means count &gt; 1)

        //
        // at this point, we have found multiple records with the same entity ID and
        // workflow, which means they differ only in the value of "step", i.e. the last
        // step done. These records represent multiple asynchronous steps which were being
        // executed in parallel by the application on one entity as part of one workflow.
        //
        // Which of these multiple wfinstances represents my current call to MarkDone()? This can
        // be identified by matching the "step" value in the input with that in the record.
        // Other records refer to other asynchronous steps.
        //
        // When we complete one step out of a set of asynchronous steps, we log this completion
        // and see if there is a next step which we can start right away, or we need to wait for
        // other asynchronous steps to complete.
        //
        set the doneat field in the current wfinstance record to the current timestamp
        look through all the other wfinstance records which have matching tuple (slice,app,workflow,entityid)
        if all of them have doneat set      // this means they are all complete
            set entity.step = the value of "nextstep" from the current wfinstance record
            invoke doMatch() with
                    entity = the object received
                    ruleset = the ruleset name retrieved from wfinstance
                    actionset and seenrulesets: empty
            if doMatch() returns with a critical error then
                return with error details
            endif
            if actionset.properties.done == true then
                delete all wfinstance records with tuple matching (slice,app,workflow,entityid)
                return specifying that the workflow is completed
            endif
            if actionset.tasks has more than one task then
                delete the old record from wfinstance and create fresh records, one per task
                return the full set of tasks and their record IDs
            else
                update the old record in wfinstance to set the value of "step" to the task returned
                return the task and other data in response
            endif
        else
            // we come here when our current step is one of a set of concurrent steps
            // and one or more of the other concurrent steps is yet to complete. In that
            // we have nothing else to do other than mark the current step complete and
            // return to the caller saying "We have marked it done, there is nothing more
            // to do till one more of the other concurrent steps completes. Keep walking."
            return with details of success of mark-done.
        endif

endif
*/
func DoMarkDone(c *gin.Context, s *service.Service, qtx *sqlc.Queries, instanceID int32, entity map[string]string) (wfinstance.WFInstanceNewResponse, error) <span class="cov8" title="1">{
        l := s.LogHarbour.WithClass("DoMarkDone")
        l.Debug1().Log("DoMarkDone function execution started")

        wfinst, err := qtx.GetWFInstanceFromId(c, instanceID)
        if err != nil </span><span class="cov8" title="1">{
                l.Debug1().Error(err)
                return wfinstance.WFInstanceNewResponse{}, fmt.Errorf("error while GetWFInstanceFromId() in WFInstanceMarkDone")
        }</span>
        <span class="cov8" title="1">cruxCache, ok := s.Dependencies["cruxCache"].(*crux.Cache)
        if !ok </span><span class="cov0" title="0">{
                l.Debug0().Debug1().Log("Error while getting cruxCache instance from service Dependencies")
                return wfinstance.WFInstanceNewResponse{}, fmt.Errorf("error while getting cruxCache instance from service Dependencies")
        }</span>

        <span class="cov8" title="1">stepfailed, err := strconv.ParseBool(entity["stepfailed"])
        if err != nil </span><span class="cov0" title="0">{
                l.Debug1().Error(err)
                return wfinstance.WFInstanceNewResponse{}, fmt.Errorf("error while converting stepfailed val from string to bool")
        }</span>
        <span class="cov8" title="1">step := entity["step"]

        schema, ruleset, err := cruxCache.RetriveRuleSchemasAndRuleSetsFromCache(WFE, wfinst.App, realmName, wfinst.Class, wfinst.Workflow, wfinst.Slice)
        if err != nil </span><span class="cov0" title="0">{
                l.Debug0().Error(err).Log("error while Retrieve RuleSchemas and RuleSets FromCache")
                return wfinstance.WFInstanceNewResponse{}, fmt.Errorf("error while Retrieve RuleSchemas and RuleSets FromCache: %v", err)
        }</span> else<span class="cov8" title="1"> if schema == nil || ruleset == nil </span><span class="cov0" title="0">{
                l.Debug0().Error(err).Log("didn't find any data in RuleSchemas or RuleSets cache")
                return wfinstance.WFInstanceNewResponse{}, fmt.Errorf("didn't find any data in RuleSchemas or RuleSets cache: ")
        }</span>

        <span class="cov8" title="1">entity_t := crux.Entity{
                Realm: realmName,
                App:   wfinst.App,
                Slice: wfinst.Slice,
                Class: wfinst.Class,
                Attrs: entity,
        }
        err = crux.VerifyEntity(entity_t, schema)
        if err != nil </span><span class="cov0" title="0">{
                l.Debug0().Error(err).Log("error while verifying entityFromCache")
                return wfinstance.WFInstanceNewResponse{}, fmt.Errorf("error while verifying entityFromCache: %v", err)
        }</span>

        <span class="cov8" title="1">var response wfinstance.WFInstanceNewResponse

        if stepfailed </span><span class="cov8" title="1">{

                actionSet := crux.ActionSet{}
                seenRuleSets := make(map[string]struct{})

                // Call the doMatch function passing the entity.entity, ruleset, and the empty actionSet and seenRuleSets
                actionset, _, err := crux.DoMatch(entity_t, ruleset, schema, actionSet, seenRuleSets)
                if err != nil </span><span class="cov0" title="0">{
                        l.Debug0().Error(err).Log("error while performing DoMatch")
                        return wfinstance.WFInstanceNewResponse{}, err
                }</span>

                <span class="cov8" title="1">if actionset.Properties[doneProp] == "true" </span><span class="cov8" title="1">{
                        res, err := doneTrue(l, qtx, instanceID, entity_t, wfinst)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Info().Error(err).Log("error while deleting wfinstance")
                                return wfinstance.WFInstanceNewResponse{}, err
                        }</span>
                        <span class="cov8" title="1">return res, nil</span>
                }

                <span class="cov0" title="0">if len(actionset.Tasks) &gt; 1 </span><span class="cov0" title="0">{
                        // Has more than one task then delete the old record from wfinstance and create fresh records, one per task

                        // call addTasks

                        entity["class"] = wfinst.Class

                        task := wfinstance.AddTaskRequest{
                                Steps:    actionset.Tasks,
                                Nextstep: actionset.Properties["nextstep"],
                                Request: wfinstance.WFInstanceNewRequest{
                                        Slice:    wfinst.Slice,
                                        App:      wfinst.App,
                                        EntityID: wfinst.Entityid,
                                        Entity:   entity,
                                        Workflow: wfinst.Workflow,
                                },
                        }

                        response, err = wfinstance.AddTasks(task, s, c)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Info().Error(err).Log("Error while AddTasks")
                                return wfinstance.WFInstanceNewResponse{}, err
                        }</span>
                        <span class="cov0" title="0">return response, nil</span>
                } else<span class="cov0" title="0"> {
                        entity["step"] = actionset.Tasks[0]
                        err = UpdateWFInstanceStep(qtx, instanceID, entity_t, actionset.Tasks[0], ruleset.SetName)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Info().Error(err).Log("Error while Update WFInstance Step")
                                return wfinstance.WFInstanceNewResponse{}, err
                        }</span>
                        <span class="cov0" title="0">response = wfinstance.WFInstanceNewResponse{
                                Tasks:    []map[string]int32{{step: instanceID}},
                                Loggedat: pgtype.Timestamp{Time: wfinst.Loggedat.Time, Valid: true},
                        }
                        return response, nil</span>
                }
        }
        // We come here k        wing that the previous step didn't fail. We can now proceed to the next step; the previous step was successful
        <span class="cov8" title="1">recordcount, _ := GetWFInstanceCountForEntity(qtx, instanceID, entity_t, ruleset.SetName)
        if recordcount == 1 </span><span class="cov8" title="1">{
                // markDoneReq.Step = step

                // Invoke doMatch() with
                // entity = the object received
                // ruleset = the ruleset name retrieved from wfinstance
                // actionset and seenrulesets: empty
                actionSet := crux.ActionSet{}
                seenRuleSets := make(map[string]struct{})

                actionset, match, err := crux.DoMatch(entity_t, ruleset, schema, actionSet, seenRuleSets)
                if err != nil </span><span class="cov0" title="0">{
                        l.Info().Error(err).Log("error while performing DoMatch")
                        return wfinstance.WFInstanceNewResponse{}, err
                }</span>

                <span class="cov8" title="1">if !match </span><span class="cov0" title="0">{
                        return wfinstance.WFInstanceNewResponse{}, fmt.Errorf("rule are not matched")
                }</span>
                <span class="cov8" title="1">if actionset.Properties[doneProp] == "true" </span><span class="cov0" title="0">{
                        res, err := doneTrue(l, qtx, instanceID, entity_t, wfinst)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Info().Error(err).Log("error while deleting wfinstance")
                                return wfinstance.WFInstanceNewResponse{}, err
                        }</span>
                        <span class="cov0" title="0">return res, nil</span>
                }

                <span class="cov8" title="1">if len(actionset.Tasks) &gt; 1 </span><span class="cov8" title="1">{
                        // Has more than one task then delete the old record from wfinstance and create fresh records, one per task
                        // Return the full set of tasks and their record IDs

                        err := deleteWFInstance(qtx, instanceID, entity_t)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Info().Error(err).Log("Error while deleteWFInstance() in DoMarkDone")
                                return wfinstance.WFInstanceNewResponse{}, err
                        }</span>
                        <span class="cov8" title="1">dclog := l.WithClass("WFInstance").WithInstanceId(string(instanceID))
                        dclog.LogDataChange("insert ruleset", logharbour.ChangeInfo{
                                Entity: "WFInstance",
                                Op:     "delete",
                                Changes: []logharbour.ChangeDetail{
                                        {
                                                Field:  "entityid",
                                                OldVal: nil,
                                                NewVal: wfinst.Entityid,
                                        },
                                        {
                                                Field:  "slice",
                                                OldVal: nil,
                                                NewVal: wfinst.Slice,
                                        },
                                        {
                                                Field:  "app",
                                                OldVal: nil,
                                                NewVal: wfinst.App,
                                        },
                                        {
                                                Field:  "class",
                                                OldVal: nil,
                                                NewVal: wfinst.Class,
                                        },
                                        {
                                                Field:  "workflow",
                                                OldVal: nil,
                                                NewVal: wfinst.Workflow,
                                        },
                                        {
                                                Field:  "step",
                                                OldVal: nil,
                                                NewVal: step,
                                        },
                                },
                        })

                        doneAtTimeStamp := time.Now()
                        err = UpdateWFInstanceDoneAt(qtx, instanceID, entity_t, doneAtTimeStamp, ruleset.SetName)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Info().Error(err).Log("Error while update wfinstance Done At() in DoMarkDone")
                                return wfinstance.WFInstanceNewResponse{}, err
                        }</span>

                        // call addTasks

                        <span class="cov8" title="1">entity["class"] = wfinst.Class

                        addTaskParam := wfinstance.AddTaskRequest{
                                Steps:    actionset.Tasks,
                                Nextstep: actionset.Properties["nextstep"],
                                Request: wfinstance.WFInstanceNewRequest{
                                        Slice:    wfinst.Slice,
                                        App:      wfinst.App,
                                        EntityID: wfinst.Entityid,
                                        Entity:   entity,
                                        Workflow: wfinst.Workflow,
                                },
                        }

                        response, err = wfinstance.AddTasks(addTaskParam, s, c)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Error(err).Log("Error while AddTasks")
                                return wfinstance.WFInstanceNewResponse{}, err
                        }</span>
                        <span class="cov8" title="1">return response, nil</span>
                } else<span class="cov0" title="0"> {
                        step = actionset.Tasks[0]
                        UpdateWFInstanceStep(qtx, instanceID, entity_t, actionset.Tasks[0], ruleset.SetName)
                        response = wfinstance.WFInstanceNewResponse{
                                Tasks:    []map[string]int32{{step: instanceID}},
                                Loggedat: pgtype.Timestamp{Time: wfinst.Doneat.Time, Valid: true},
                        }
                        return response, nil
                }</span>
        } else<span class="cov8" title="1"> if recordcount &gt; 1 </span><span class="cov8" title="1">{
                // At this point, we have found multiple records with the same entity ID and workflow, which means they differ only in the value of "step"
                // Set the doneat field in the current wfinstance record to the current timestamp
                doneAtTimeStamp := time.Now()
                err := UpdateWFInstanceDoneAt(qtx, instanceID, entity_t, doneAtTimeStamp, ruleset.SetName)
                if err != nil </span><span class="cov0" title="0">{
                        l.Info().Error(err).Log("Error while update wfinstance Done At() in DoMarkDone")
                        return wfinstance.WFInstanceNewResponse{}, err
                }</span>
                // Look through all the other wfinstance records which have matching tuple (slice,app,workflow,entityid)
                <span class="cov8" title="1">wfInstances, err := getWFInstanceList(qtx, instanceID, entity_t, ruleset.SetName)
                if err != nil </span><span class="cov0" title="0">{
                        l.Info().Error(err).Log("Error while getWFInstanceList() in DoMarkDone")
                        return wfinstance.WFInstanceNewResponse{}, err
                }</span>

                // Check if all other wfinstance records have doneat set
                <span class="cov8" title="1">allDone := true
                for _, wfInstance := range wfInstances </span><span class="cov8" title="1">{
                        v, err := wfInstance.Doneat.Value()
                        if err != nil </span><span class="cov0" title="0">{
                                return wfinstance.WFInstanceNewResponse{}, err
                        }</span>

                        <span class="cov8" title="1">if v == nil </span><span class="cov8" title="1">{
                                allDone = false
                                break</span>
                        }
                }

                <span class="cov8" title="1">if allDone </span><span class="cov8" title="1">{

                        // The value of "nextstep" from the current wfinstance record
                        // Invoke doMatch() with
                        //  entity = the object received
                        // ruleset = the ruleset name retrieved from wfinstance
                        // actionset and seenrulesets: empty
                        actionSet := crux.ActionSet{}
                        seenRuleSets := make(map[string]struct{})
                        entity_t.Attrs["step"] = wfinst.Nextstep
                        actionset, _, err := crux.DoMatch(entity_t, ruleset, schema, actionSet, seenRuleSets)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Info().Error(err).Log("error while performing DoMatch")
                                return wfinstance.WFInstanceNewResponse{}, err
                        }</span>

                        <span class="cov8" title="1">if actionset.Properties[doneProp] == "true" </span><span class="cov0" title="0">{

                                res, err := doneTrue(l, qtx, instanceID, entity_t, wfinst)
                                if err != nil </span><span class="cov0" title="0">{
                                        l.Info().Error(err).Log("error while deleting wfinstance")
                                        return wfinstance.WFInstanceNewResponse{}, err
                                }</span>
                                <span class="cov0" title="0">return res, nil</span>
                        }

                        <span class="cov8" title="1">if len(actionset.Tasks) &gt;= 1 </span><span class="cov8" title="1">{
                                // Delete the old record from wfinstance and create fresh records, one per task
                                // Return the full set of tasks and their record IDs
                                err := deleteWFInstance(qtx, instanceID, entity_t)
                                if err != nil </span><span class="cov0" title="0">{
                                        l.Info().Error(err).Log("Error while deleteWFInstance() in DoMarkDone")
                                        return wfinstance.WFInstanceNewResponse{}, err
                                }</span>
                                <span class="cov8" title="1">dclog := l.WithClass("WFInstance").WithInstanceId(string(instanceID))
                                dclog.LogDataChange("insert ruleset", logharbour.ChangeInfo{
                                        Entity: "WFInstance",
                                        Op:     "delete",
                                        Changes: []logharbour.ChangeDetail{
                                                {
                                                        Field:  "entityid",
                                                        OldVal: nil,
                                                        NewVal: wfinst.Entityid,
                                                },
                                                {
                                                        Field:  "slice",
                                                        OldVal: nil,
                                                        NewVal: wfinst.Slice,
                                                },
                                                {
                                                        Field:  "app",
                                                        OldVal: nil,
                                                        NewVal: wfinst.App,
                                                },
                                                {
                                                        Field:  "class",
                                                        OldVal: nil,
                                                        NewVal: wfinst.Class,
                                                },
                                                {
                                                        Field:  "workflow",
                                                        OldVal: nil,
                                                        NewVal: wfinst.Workflow,
                                                },
                                                {
                                                        Field:  "step",
                                                        OldVal: nil,
                                                        NewVal: step,
                                                },
                                        },
                                })

                                // call addTasks

                                entity["class"] = wfinst.Class

                                task := wfinstance.AddTaskRequest{
                                        Steps:    actionset.Tasks,
                                        Nextstep: actionset.Properties["nextstep"],
                                        Request: wfinstance.WFInstanceNewRequest{
                                                Slice:    wfinst.Slice,
                                                App:      wfinst.App,
                                                EntityID: wfinst.Entityid,
                                                Entity:   entity,
                                                Workflow: wfinst.Workflow,
                                        },
                                }

                                response, err = wfinstance.AddTasks(task, s, c)
                                if err != nil </span><span class="cov0" title="0">{
                                        l.Error(err).Log("Error while AddTasks")
                                        return wfinstance.WFInstanceNewResponse{}, err
                                }</span>
                                <span class="cov8" title="1">return response, nil</span>
                        } else<span class="cov0" title="0"> {
                                step = actionset.Tasks[0]
                                UpdateWFInstanceStep(qtx, instanceID, entity_t, actionset.Tasks[0], ruleset.SetName)
                                response = wfinstance.WFInstanceNewResponse{
                                        Tasks:    []map[string]int32{{step: instanceID}},
                                        Loggedat: pgtype.Timestamp{Time: wfinst.Doneat.Time, Valid: true},
                                }
                                return response, nil
                        }</span>

                } else<span class="cov8" title="1"> {
                        // We come here when our current step is one of a set of concurrent steps
                        // and one or more of the other concurrent steps is yet to complete.
                        // In that, we have nothing else to do other than mark the current step complete
                        // and return to the caller saying "We have marked it done, there is nothing more
                        // to do till one more of the other concurrent steps completes. Keep walking."
                        // Return with details of success of mark-done.
                        id := strconv.Itoa(int(instanceID))
                        response := wfinstance.WFInstanceNewResponse{
                                ID:       id,
                                Loggedat: pgtype.Timestamp{Time: wfinst.Doneat.Time, Valid: true},
                        }
                        return response, nil
                }</span>

        }
        <span class="cov0" title="0">return wfinstance.WFInstanceNewResponse{}, errors.New("schema Realmkey not match")</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package markdone

import (
        "context"
        "log"
        "time"

        "github.com/jackc/pgx/v5/pgtype"

        sqlc "github.com/remiges-tech/crux/db/sqlc-gen"
        crux "github.com/remiges-tech/crux/matching-engine"
        "github.com/remiges-tech/crux/server/wfinstance"
        "github.com/remiges-tech/logharbour/logharbour"
)

func deleteWFInstance(queries *sqlc.Queries, instanceID int32, entity crux.Entity) error <span class="cov8" title="1">{
        params := sqlc.DeleteWFInstancesParams{
                Slice: entity.Slice,
                App:   entity.App,
                ID:    instanceID,
        }
        return queries.DeleteWFInstances(context.Background(), params)
}</span>

func GetWFInstanceCountForEntity(queries *sqlc.Queries, instanceID int32, entity crux.Entity, workflowname string) (int64, error) <span class="cov8" title="1">{
        params := sqlc.GetWFInstanceCountsParams{
                Slice:    entity.Slice,
                App:      entity.App,
                Workflow: workflowname,
                ID:       instanceID,
        }
        count, err := queries.GetWFInstanceCounts(context.Background(), params)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error running GetWFInstanceCounts: %v", err)
        }</span>
        <span class="cov8" title="1">return count, err</span>

}
func UpdateWFInstanceStep(queries *sqlc.Queries, instanceID int32, entity crux.Entity, step string, workflowname string) error <span class="cov0" title="0">{

        params := sqlc.UpdateWFInstanceStepParams{
                Slice:    entity.Slice,
                App:      entity.App,
                ID:       int32(instanceID),
                Step:     step,
                Workflow: workflowname,
        }

        return queries.UpdateWFInstanceStep(context.Background(), params)

}</span>
func UpdateWFInstanceDoneAt(queries *sqlc.Queries, instanceID int32, entity crux.Entity, t time.Time, wf string) error <span class="cov8" title="1">{

        // id := strconv.Itoa(int(instanceID))
        params := sqlc.UpdateWFInstanceDoneatParams{
                Doneat:   pgtype.Timestamp{Time: t, Valid: true},
                ID:       instanceID,
                Slice:    entity.Slice,
                App:      entity.App,
                Workflow: wf,
        }

        return queries.UpdateWFInstanceDoneat(context.Background(), params)

}</span>

func getWFInstanceList(queries *sqlc.Queries, instanceID int32, entity crux.Entity, wf string) ([]sqlc.Wfinstance, error) <span class="cov8" title="1">{

        parent := &amp;pgtype.Int4{} // Ensure parent is of type pgx/v5/pgtype.Int4
        parent.Int32 = instanceID
        params := sqlc.GetWFInstanceListForMarkDoneParams{
                ID:       instanceID,
                Slice:    entity.Slice,
                App:      entity.App,
                Workflow: wf,
        }
        list, err := queries.GetWFInstanceListForMarkDone(context.Background(), params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return list, nil</span>
}

func doneTrue(l *logharbour.Logger, qtx *sqlc.Queries, instanceID int32, entity_t crux.Entity, wfinst sqlc.Wfinstance) (wfinstance.WFInstanceNewResponse, error) <span class="cov8" title="1">{
        // Delete all wfinstance records with tuple matching (slice, app, workflow, entityid)
        // Return specifying that the workflow is completed

        err := deleteWFInstance(qtx, instanceID, entity_t)
        if err != nil </span><span class="cov0" title="0">{
                l.Info().Error(err).Log("Error while deleteWFInstance() in DoMarkDone")
                return wfinstance.WFInstanceNewResponse{}, err
        }</span>
        <span class="cov8" title="1">dclog := l.WithClass("WFInstance").WithInstanceId(string(instanceID))
        dclog.LogDataChange("insert ruleset", logharbour.ChangeInfo{
                Entity: "WFInstance",
                Op:     "delete",
                Changes: []logharbour.ChangeDetail{
                        {
                                Field:  "entityid",
                                OldVal: nil,
                                NewVal: wfinst.Entityid,
                        },
                        {
                                Field:  "slice",
                                OldVal: nil,
                                NewVal: wfinst.Slice,
                        },
                        {
                                Field:  "app",
                                OldVal: nil,
                                NewVal: wfinst.App,
                        },
                        {
                                Field:  "class",
                                OldVal: nil,
                                NewVal: wfinst.Class,
                        },
                        {
                                Field:  "workflow",
                                OldVal: nil,
                                NewVal: wfinst.Workflow,
                        },
                        {
                                Field:  "step",
                                OldVal: nil,
                                NewVal: entity_t.Attrs["step"],
                        },
                },
        })
        return wfinstance.WFInstanceNewResponse{
                Done: "true",
        }, nil</span>

}
</pre>
		
		<pre class="file" id="file21" style="display: none">package markdone

import (
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/crux/server"
        "github.com/remiges-tech/crux/types"
)

var (
        userID    = "1234"
        realmName = "BSE"
)

type WFInstanceMarkDoneReq struct {
        ID         int32             `json:"id" validate:"required,lt=50"`
        Entity     map[string]string `json:"entity" validate:"required,lt=50"`
        Step       string            `json:"step" validate:"required,lt=50"`
        Stepfailed bool              `json:"stepfailed,omitempty"`
        Trace      int               `json:"trace,omitempty"`
}

func WFInstanceMarkDone(c *gin.Context, s *service.Service) <span class="cov8" title="1">{
        l := s.LogHarbour
        l.Debug0().Log("starting execution of WFInstanceMarkDone()")

        // userID, err := server.ExtractUserNameFromJwt(c)
        // if err != nil {
        //         l.Info().Log("unable to extract userID from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ErrCode_Token_Data_Missing))
        //         return
        // }

        // realmName, err := server.ExtractRealmFromJwt(c)
        // if err != nil {
        //         l.Info().Log("unable to extract realm from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ErrCode_Token_Data_Missing))
        //         return
        // }
        reqCaps := []string{"root"}
        isCapable, _ := server.Authz_check(types.OpReq{
                User:      userID,
                CapNeeded: reqCaps,
        }, false)

        if !isCapable </span><span class="cov0" title="0">{
                l.Info().LogActivity("Unauthorized user:", userID)
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Unauthorized, server.ErrCode_Unauthorized))
                return
        }</span>
        <span class="cov8" title="1">l.Info().Log("Authz_check completed")

        var req WFInstanceMarkDoneReq

        err := wscutils.BindJSON(c, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                l.Error(err).Debug0().Log("Error Unmarshalling Query parameters to struct:")
                return
        }</span>
        // Validate request
        <span class="cov8" title="1">validationErrors := wscutils.WscValidate(req, func(err validator.FieldError) []string </span><span class="cov8" title="1">{ return []string{} }</span>)
        <span class="cov8" title="1">if len(validationErrors) &gt; 0 </span><span class="cov8" title="1">{
                l.Debug0().LogDebug("validation errors", validationErrors)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, validationErrors))
                return
        }</span>

        <span class="cov8" title="1">queries, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                l.Debug0().Debug1().Log("Error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                return
        }</span>

        <span class="cov8" title="1">connpool, ok := s.Database.(*pgxpool.Pool)
        if !ok </span><span class="cov0" title="0">{
                l.Debug0().Debug1().Log("Error while getting connection pool instance from service Database")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                return
        }</span>
        <span class="cov8" title="1">tx, err := connpool.Begin(c)
        if err != nil </span><span class="cov0" title="0">{
                l.Error(err).Err().Log("Error while Begin tx")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback(c)
        qtx := queries.WithTx(tx)

        // get instance record
        // wfinstance, err := queries.GetWFInstanceFromId(c, req.ID)
        // if err != nil {
        //         l.Err().Error(err).Log("Error while GetWFInstanceFromId() in WFInstanceMarkDone")
        //         errmsg := db.HandleDatabaseError(err)
        //         wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{errmsg}))
        //         return
        // }

        req.Entity["step"] = req.Step
        req.Entity["stepfailed"] = strconv.FormatBool(req.Stepfailed)

        // var DoMarkDoneParam = Markdone_t{
        //         InstanceID: wfinstance.ID,
        //         EntityID:   wfinstance.Entityid,
        //         Workflow:   wfinstance.Workflow,
        //         Loggedat:   wfinstance.Loggedat.Time,
        //         Entity: crux.Entity{
        //                 Realm: realmName,
        //                 App:   wfinstance.App,
        //                 Slice: wfinstance.Slice,
        //                 Class: wfinstance.Class,
        //                 Attrs: req.Entity,
        //         },
        // }

        ResponseData, err := DoMarkDone(c, s, qtx, req.ID, req.Entity)
        if err != nil </span><span class="cov8" title="1">{
                l.Err().Error(err).Log("Error in DoMarkDone")
                wscutils.SendErrorResponse(c, &amp;wscutils.Response{Status: "error", Data: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(c); err != nil </span><span class="cov0" title="0">{
                l.Err().Error(err).Log("Error while commits the transaction")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                return
        }</span>
        <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: ResponseData, Messages: nil})
        l.Debug0().Log("finished execution of WFInstanceMarkDone()")</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package wfinstance

import (
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/crux/server"
        "github.com/remiges-tech/crux/types"
        "github.com/remiges-tech/logharbour/logharbour"
)

// AbortWFInstance rquest format
type WFInstanceAbortRquest struct {
        ID       *int32  `json:"id" validate:"omitempty,gt=0"`
        EntityID *string `json:"entityid" validate:"omitempty,gt=0,lt=40"`
}

func GetWFInstanceAbort(c *gin.Context, s *service.Service) <span class="cov0" title="0">{
        lh := s.LogHarbour.WithClass("wfinstance")
        lh.Log("GetWFInstanceAbort request received")

        var (
                request  WFInstanceAbortRquest
                id       int32
                entityid string
        )
        userID, err := server.ExtractUserNameFromJwt(c)
        if err != nil </span><span class="cov0" title="0">{
                lh.Info().Log("unable to extract userID from token")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ErrCode_Token_Data_Missing))
                return
        }</span>

        // realm, err := server.ExtractRealmFromJwt(c)
        // if err != nil {
        //         lh.Info().Log("unable to extract realm from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ErrCode_Token_Data_Missing))
        //         return
        // }

        <span class="cov0" title="0">isCapable, _ := server.Authz_check(types.OpReq{
                User: userID,
        }, false)

        if !isCapable </span><span class="cov0" title="0">{
                lh.Info().LogActivity("GetWFInstanceAbort||unauthorized user:", userID)
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Unauthorized, server.ErrCode_Unauthorized))
                return
        }</span>

        // Bind request
        <span class="cov0" title="0">err = wscutils.BindJSON(c, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                lh.Error(err).Log("GetWFInstanceAbort||error while binding json request error:")
                return
        }</span>
        // Standard validation of Incoming Request
        <span class="cov0" title="0">validationErrors := wscutils.WscValidate(request, func(err validator.FieldError) []string </span><span class="cov0" title="0">{ return []string{} }</span>)
        <span class="cov0" title="0">if len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                lh.Debug0().LogActivity("GetWFInstanceAbort||validation error:", validationErrors)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, validationErrors))
                return
        }</span>
        // Custom validation
        <span class="cov0" title="0">if request.ID != nil &amp;&amp; request.EntityID != nil </span><span class="cov0" title="0">{
                lh.Debug0().Log("GetWFInstanceAbort||both id and entityid cannot be present at the same time")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_RequiredOneOf, server.ErrCode_RequiredOne))
                return
        }</span>
        <span class="cov0" title="0">if request.ID == nil &amp;&amp; request.EntityID == nil </span><span class="cov0" title="0">{
                lh.Debug0().Log("GetWFInstanceAbort||either id or entityid must be present")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_RequiredOneOf, server.ErrCode_RequiredOne))
                return
        }</span>

        //Handle the request based on the presence of ID or EntityID
        <span class="cov0" title="0">if request.ID != nil </span><span class="cov0" title="0">{
                id = *request.ID
                lh.WithInstanceId(string(id))
        }</span> else<span class="cov0" title="0"> {
                entityid = *request.EntityID
        }</span>
        <span class="cov0" title="0">lh.Debug0().LogActivity("GetWFInstanceAbort||present values :", map[string]any{"ID": id, "EntityId": entityid})

        query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                lh.Log("GetWFInstanceAbort||error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
        }</span>
        // delete wfinstance by ID or entityID
        <span class="cov0" title="0">deletedWfinstaceListByID, error := query.DeleteWfinstanceByID(c, sqlc.DeleteWfinstanceByIDParams{
                ID:       pgtype.Int4{Int32: id, Valid: id != 0},
                Entityid: pgtype.Text{String: entityid, Valid: !server.IsStringEmpty(&amp;entityid)},
        })
        if error != nil </span><span class="cov0" title="0">{
                lh.Error(error).Log("GetWFInstanceAbort||error while deleting wfinstances by id or entityid")
                errmsg := db.HandleDatabaseError(err)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{errmsg}))
                return
        }</span>

        <span class="cov0" title="0">if len(deletedWfinstaceListByID) == 0 </span><span class="cov0" title="0">{
                lh.Log("GetWFInstanceAbort||no record found to delete")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_NotFound, server.ErrCode_NotFound))
                return
        }</span>

        // To Get parentList from WFInstanceList data
        <span class="cov0" title="0">parentList := getParentList(deletedWfinstaceListByID)
        lh.Debug0().LogActivity("GetWFInstanceAbort||parentlist form WFInstanceListByID data:", parentList)

        for parentList != nil </span><span class="cov0" title="0">{
                lh.Debug0().Log("GetWFInstanceAbort||inside for loop : if parentList is Not Nil ")
                // To get GetWFInstanceList by parentList
                deletedWfinstanceListByParents, err := query.DeleteWFInstanceListByParents(c, sqlc.DeleteWFInstanceListByParentsParams{
                        ID:     parentList,
                        Parent: parentList,
                })
                if err != nil </span><span class="cov0" title="0">{
                        lh.Error(err).Log("GetWFInstanceAbort||error while getting wfinstance List by parentList")
                        errmsg := db.HandleDatabaseError(err)
                        wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{errmsg}))
                        return
                }</span>

                // Append wfinstanceListByParents data
                <span class="cov0" title="0">deletedWfinstaceListByID = append(deletedWfinstaceListByID, deletedWfinstanceListByParents...)

                // Update parentList using getParentList function
                parentList = getParentList(deletedWfinstanceListByParents)
                lh.Debug0().LogActivity("GetWFInstanceAbort||updated ParentList :", parentList)</span>
        }

        // data change log
        <span class="cov0" title="0">for _, val := range deletedWfinstaceListByID </span><span class="cov0" title="0">{
                dclog := lh.WithClass("wfinstance").WithInstanceId(strconv.Itoa(int(val.ID)))
                dclog.LogDataChange("deleted wfinstance ", logharbour.ChangeInfo{
                        Entity: "wfinstance",
                        Op:     "delete",
                        Changes: []logharbour.ChangeDetail{
                                {
                                        Field:  "row",
                                        OldVal: val,
                                        NewVal: nil},
                        },
                })
        }</span>

        <span class="cov0" title="0">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus})</span>

}
</pre>
		
		<pre class="file" id="file23" style="display: none">package wfinstance

import (
        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/crux/server"
        "github.com/remiges-tech/crux/types"
)

// WFInstanceList rquest format
type WFInstanceListRequest struct {
        Slice    *int32  `json:"slice" validate:"omitempty,gt=0,lt=50"`
        EntityID *string `json:"entityid" validate:"omitempty,gt=0,lt=40"`
        App      *string `json:"app" validate:"omitempty,alpha,gt=0,lt=15"`
        Workflow *string `json:"workflow" validate:"omitempty,gt=0,lt=20"`
        Parent   *int32  `json:"parent" validate:"omitempty,gt=0"`
}

// WFInstanceList response format
type WFInstanceListResponse struct {
        ID         int32            `json:"id"`
        EntityID   string           `json:"entityid"`
        Slice      int32            `json:"slice"`
        App        string           `json:"app"`
        Class      string           `json:"class"`
        Workflow   string           `json:"workflow"`
        Step       string           `json:"step"`
        LoggedDate pgtype.Timestamp `json:"loggedat"`
        DoneAt     string           `json:"doneat"`
        Nextstep   string           `json:"nextstep"`
        Parent     int32            `json:"parent,omitempty"`
}

type WFInstanceListParams struct {
        Slice    int32
        EntityID string
        App      string
        Workflow string
        Parent   int32
}

func GetWFInstanceList(c *gin.Context, s *service.Service) <span class="cov0" title="0">{
        lh := s.LogHarbour.WithClass("wfinstance")
        lh.Log("GetWFInstanceList request received")

        var (
                request WFInstanceListRequest
                params  WFInstanceListParams
        )

        userID, err := server.ExtractUserNameFromJwt(c)
        if err != nil </span><span class="cov0" title="0">{
                lh.Info().Log("unable to extract userID from token")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ErrCode_Token_Data_Missing))
                return
        }</span>

        // realm, err := server.ExtractRealmFromJwt(c)
        // if err != nil {
        //         lh.Info().Log("unable to extract realm from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ErrCode_Token_Data_Missing))
        //         return
        // }
        <span class="cov0" title="0">isCapable, _ := server.Authz_check(types.OpReq{
                User: userID,
        }, false)

        if !isCapable </span><span class="cov0" title="0">{
                lh.Info().LogActivity("GetWFInstanceList||unauthorized user:", userID)
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Unauthorized, server.ErrCode_Unauthorized))
                return
        }</span>

        // Bind request
        <span class="cov0" title="0">err = wscutils.BindJSON(c, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                lh.Error(err).Log("GetWFInstanceList||error while binding json request error")
                return
        }</span>

        // Check for validation error
        <span class="cov0" title="0">valError := wscutils.WscValidate(request, func(err validator.FieldError) []string </span><span class="cov0" title="0">{ return []string{} }</span>)
        <span class="cov0" title="0">if len(valError) &gt; 0 </span><span class="cov0" title="0">{
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, valError))
                lh.LogActivity("GetWFInstanceList||validation error:", valError)
                return
        }</span>

        // To get request parameters
        <span class="cov0" title="0">params = GetParams(request, params)
        lh.Debug0().LogActivity("GetWFInstanceList|parameters from request :", params)

        query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                lh.Log("GetWFInstanceList||error while getting query instance from service dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                return
        }</span>

        // To get requested wfinstance list
        <span class="cov0" title="0">wfinstanceList, error := query.GetWFInstanceList(c, sqlc.GetWFInstanceListParams{
                Slice:    pgtype.Int4{Int32: params.Slice, Valid: params.Slice != 0},
                Entityid: pgtype.Text{String: params.EntityID, Valid: !server.IsStringEmpty(&amp;params.EntityID)},
                App:      pgtype.Text{String: params.App, Valid: !server.IsStringEmpty(&amp;params.App)},
                Workflow: pgtype.Text{String: params.Workflow, Valid: !server.IsStringEmpty(&amp;params.Workflow)},
                Parent:   pgtype.Int4{Int32: params.Parent, Valid: params.Parent != 0},
        })
        if error != nil </span><span class="cov0" title="0">{
                lh.Error(error).Log("GetWFInstanceList||error while getting wfinstance List")
                errmsg := db.HandleDatabaseError(err)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{errmsg}))
                return
        }</span>

        <span class="cov0" title="0">if len(wfinstanceList) == 0 </span><span class="cov0" title="0">{
                lh.Debug0().Log("GetWFInstanceList||requestd wfinstanceList not found")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_NotFound, server.ErrCode_NotFound))
                return
        }</span>

        // To Get parentList from WFInstanceList data
        <span class="cov0" title="0">parentList := getParentList(wfinstanceList)
        lh.Debug0().LogActivity("GetWFInstanceList||parentlist form WFInstanceList data:", parentList)

        for parentList != nil </span><span class="cov0" title="0">{
                lh.Debug0().Log("GetWFInstanceList||inside for loop : if parentList is Not Nil ")
                // To get GetWFInstanceList by parentList
                wfinstanceListByParents, err := query.GetWFInstanceListByParents(c, parentList)
                if err != nil </span><span class="cov0" title="0">{
                        lh.Error(err).Log("GetWFInstanceList||error while getting wfinstance List by parentList")
                        errmsg := db.HandleDatabaseError(err)
                        wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{errmsg}))
                        return
                }</span>

                // Append wfinstanceListByParents data
                <span class="cov0" title="0">wfinstanceList = append(wfinstanceList, wfinstanceListByParents...)

                // Update parentList using getParentList function
                parentList = getParentList(wfinstanceListByParents)
                lh.Debug0().LogActivity("GetWFInstanceList||updated ParentList :", parentList)</span>
        }
        <span class="cov0" title="0">var responseList []WFInstanceListResponse
        for _, val := range wfinstanceList </span><span class="cov0" title="0">{
                var response WFInstanceListResponse
                response.ID = val.ID
                response.EntityID = val.Entityid
                response.Slice = val.Slice
                response.App = val.App
                response.Class = val.Class
                response.Workflow = val.Workflow
                response.Step = val.Step
                response.LoggedDate = val.Loggedat
                response.Nextstep = val.Nextstep

                // Handling the omitted Parent field
                if val.Parent.Valid </span><span class="cov0" title="0">{
                        response.Parent = val.Parent.Int32
                }</span>

                // Handling the DoneAt field
                <span class="cov0" title="0">if !val.Doneat.Valid </span><span class="cov0" title="0">{
                        response.DoneAt = ""
                }</span> else<span class="cov0" title="0"> {
                        response.DoneAt = val.Doneat.Time.String()
                }</span>

                <span class="cov0" title="0">responseList = append(responseList, response)</span>
        }

        <span class="cov0" title="0">lh.Debug0().Log("Record found finished execution of GetWFInstanceList request")
        wscutils.SendSuccessResponse(c, wscutils.NewSuccessResponse(map[string][]WFInstanceListResponse{"wfinstance": responseList}))</span>
}

// To Get Parameters from WFInstanceList Request
func GetParams(req WFInstanceListRequest, params WFInstanceListParams) WFInstanceListParams <span class="cov0" title="0">{

        if req.Slice != nil </span><span class="cov0" title="0">{
                params.Slice = *req.Slice
        }</span>
        <span class="cov0" title="0">if req.EntityID != nil </span><span class="cov0" title="0">{
                params.EntityID = *req.EntityID
        }</span>
        <span class="cov0" title="0">if req.App != nil </span><span class="cov0" title="0">{
                params.App = *req.App
        }</span>
        <span class="cov0" title="0">if req.Workflow != nil </span><span class="cov0" title="0">{
                params.Workflow = *req.Workflow
        }</span>
        <span class="cov0" title="0">if req.Parent != nil </span><span class="cov0" title="0">{
                params.Parent = *req.Parent
        }</span>
        <span class="cov0" title="0">return params</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package wfinstance

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        crux "github.com/remiges-tech/crux/matching-engine"
        "github.com/remiges-tech/crux/server"
        "github.com/remiges-tech/crux/types"
)

// Incoming request format
type WFInstanceNewRequest struct {
        Slice    int32             `json:"slice" validate:"required,gt=0"`
        App      string            `json:"app" validate:"required,lt=50"`
        EntityID string            `json:"entityid" validate:"required,gt=0,lt=40"`
        Entity   map[string]string `json:"entity" validate:"required"`
        Workflow string            `json:"workflow" validate:"required,gt=0,lt=50"`
        Trace    *int              `json:"trace,omitempty"`
        Parent   *int32            `json:"parent,omitempty"`
}

// WFInstanceNew response format
type WFInstanceNewResponse struct {
        Tasks     []map[string]int32 `json:"tasks,omitempty"`
        Nextstep  string            `json:"nextstep,omitempty"`
        Loggedat  pgtype.Timestamp   `json:"loggedat,omitempty"`
        Subflows  map[string]string `json:"subflows,omitempty"`
        Tracedata map[string]string `json:"tracedata,omitempty"`
        Done      string             `json:"done,omitempty"`
        ID        string             `json:"id,omitempty"` //wfinstance id
}

const WFE = "W"

// GetWFinstanceNew will be responsible for processing the /wfinstanceNew request that comes through as a POST
func GetWFinstanceNew(c *gin.Context, s *service.Service) <span class="cov0" title="0">{
        lh := s.LogHarbour.WithClass("wfinstance")
        lh.Log("GetWFinstanceNew request received")

        var (
                wfinstanceNewreq WFInstanceNewRequest
                actionSet        crux.ActionSet
                seenRuleSets     = make(map[string]struct{})
                response         WFInstanceNewResponse
                attribute        map[string]string
                done, nextStep   string
                steps            []string
                // ruleSet          *crux.Ruleset_t
        )
        // userID, err := server.ExtractUserNameFromJwt(c)
        // if err != nil {
        //         lh.Info().Log("unable to extract userID from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ErrCode_Token_Data_Missing))
        //         return
        // }

        // realm, err := server.ExtractRealmFromJwt(c)
        // if err != nil {
        //         lh.Info().Log("unable to extract realm from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ErrCode_Token_Data_Missing))
        //         return
        // }

        isCapable, _ := server.Authz_check(types.OpReq{
                User: userID,
        }, false)

        if !isCapable </span><span class="cov0" title="0">{
                lh.Info().LogActivity("unauthorized user:", userID)
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Unauthorized, server.ErrCode_Unauthorized))
                return
        }</span>

        // Bind request
        <span class="cov0" title="0">err := wscutils.BindJSON(c, &amp;wfinstanceNewreq)
        if err != nil </span><span class="cov0" title="0">{
                lh.Error(err).Log("GetWFinstanceNew||error while binding json request error")
                return
        }</span>
        // Standard validation of Incoming Request
        <span class="cov0" title="0">validationErrors := wscutils.WscValidate(wfinstanceNewreq, func(err validator.FieldError) []string </span><span class="cov0" title="0">{ return []string{} }</span>)
        <span class="cov0" title="0">if len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                lh.Debug0().LogActivity("GetWFinstanceNew||validation error:", validationErrors)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, validationErrors))
                return
        }</span>
        // Validate request
        <span class="cov0" title="0">existingEntity := wfinstanceNewreq.Entity
        isValidReq, errStr := validateWFInstanceNewReq(wfinstanceNewreq, realm, s, c)
        if len(errStr) &gt; 0 || !isValidReq </span><span class="cov0" title="0">{
                lh.Debug0().LogActivity("GetWFinstanceNew||request validation error:", errStr)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, errStr))
                return

        }</span> else<span class="cov0" title="0"> {
                // Additional attributes to append
                existingEntity[STEP] = START
                // existingEntity[STEPFALED] = FALSE
        }</span>
        <span class="cov0" title="0">lh.Debug0().LogActivity("wfinstanceNewRequest after adding additional attributes :", wfinstanceNewreq)

        //  doMatch() Processing

        // To get Entity
        entity := getEntityStructure(wfinstanceNewreq, realm)

        // To get workflow rulesets from RuleSetCache
        // ruleSet = crux.GetWorkflowFromCacheWithName(crux.Realm_t(REALM), crux.App_t(wfinstanceNewreq.App), crux.Slice_t(wfinstanceNewreq.Slice), crux.ClassName_t(wfinstanceNewreq.Entity["class"]), wfinstanceNewreq.Workflow)
        // fmt.Println("?&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;ruleset  ", ruleSet)
        // if ruleSet == nil {
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Invalid, server.ErrCode_Invalid))
        // }

        // query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        // if !ok {
        //         lh.Debug0().Log("Error while getting query instance from service Dependencies")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
        //         return
        // }

        cruxCache, ok := s.Dependencies["cruxCache"].(*crux.Cache)
        if !ok </span><span class="cov0" title="0">{
                lh.Debug0().Debug1().Log("Error while getting cruxCache instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                return
        }</span>

        <span class="cov0" title="0">class := wfinstanceNewreq.Entity["class"]
        schema, ruleset, err := cruxCache.RetriveRuleSchemasAndRuleSetsFromCache(WFE, wfinstanceNewreq.App, realm, class, wfinstanceNewreq.Workflow, wfinstanceNewreq.Slice)
        if err != nil </span><span class="cov0" title="0">{
                lh.Debug0().Error(err).Log("error while Retrieve RuleSchemas and RuleSets FromCache")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Invalid, err.Error()))
                return
        }</span> else<span class="cov0" title="0"> if schema == nil || ruleset == nil </span><span class="cov0" title="0">{
                lh.Debug0().Error(err).Log("didn't find any data in RuleSchemas or RuleSets cache")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Invalid, err.Error()))
                return
        }</span>

        // for _, r := range ruleSets {
        //         if r.SetName == wfinstanceNewreq.Workflow {
        //                 ruleSet = r
        //         }

        // }

        // call DoMatch()
        <span class="cov0" title="0">actionSet, _, err = crux.DoMatch(entity, ruleset, schema, actionSet, seenRuleSets)
        if err != nil </span><span class="cov0" title="0">{
                lh.Error(err).Log("GetWFinstanceNew||error while calling doMatch Method")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Invalid, err.Error()))
                return
        }</span>

        //To verify actionSet Properties and get their values
        <span class="cov0" title="0">attribute, error := getValidPropertyAttr(actionSet)
        if error != nil </span><span class="cov0" title="0">{
                lh.Debug0().LogActivity("GetWFinstanceNew||error while verifying actionset properties :", error.Error())
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Invalid, server.ErrCode_Invalid_property_attributes))
                return
        }</span>
        <span class="cov0" title="0">if attribute[DONE] == TRUE </span><span class="cov0" title="0">{
                done = attribute[DONE]
        }</span> else<span class="cov0" title="0"> {
                nextStep = attribute[NEXTSTEP]
        }</span>

        <span class="cov0" title="0">if done == TRUE </span><span class="cov0" title="0">{
                response := make(map[string]bool)
                response[DONE] = true
                lh.Log("Finished execution of GetWFinstanceNew")
                wscutils.SendSuccessResponse(c, wscutils.NewSuccessResponse(response))
        }</span>

        // To add records in table
        <span class="cov0" title="0">steps = actionSet.Tasks

        // if tasks of actionset contains only one task
        if len(actionSet.Tasks) == 1 &amp;&amp; done == "" </span><span class="cov0" title="0">{
                addTaskRequest := AddTaskRequest{
                        Steps:    steps,
                        Nextstep: steps[0],
                        Request:  wfinstanceNewreq,
                }
                response, err = AddTasks(addTaskRequest, s, c)
                if err != nil </span><span class="cov0" title="0">{
                        lh.Error(err).Log("GetWFinstanceNew||error while adding single step in wfinstance table")
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                        return
                }</span>
                <span class="cov0" title="0">lh.Log("Finished execution of GetWFinstanceNew")
                wscutils.SendSuccessResponse(c, wscutils.NewSuccessResponse(response))
                return</span>
        }
        // if tasks of actionset contains multiple tasks
        <span class="cov0" title="0">if len(actionSet.Tasks) &gt; 1 &amp;&amp; done == "" </span><span class="cov0" title="0">{
                addTaskRequest := AddTaskRequest{
                        Steps:    steps,
                        Nextstep: nextStep,
                        Request:  wfinstanceNewreq,
                }
                response, err = AddTasks(addTaskRequest, s, c)
                if err != nil </span><span class="cov0" title="0">{
                        lh.Error(err).Log("GetWFinstanceNew||error while adding multiple steps in wfinstance table")
                        wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                        return
                }</span>
                <span class="cov0" title="0">lh.Log("Finished execution of GetWFinstanceNew")
                wscutils.SendSuccessResponse(c, wscutils.NewSuccessResponse(response))</span>
        }

}

// To verify whether actionset.properties attributes valid and get their values
func getValidPropertyAttr(a crux.ActionSet) (map[string]string, error) <span class="cov0" title="0">{
        attribute := make(map[string]string)
        attributes := a.Properties

        isDoneOrNextStepPresent := false
        for attr, val := range attributes </span><span class="cov0" title="0">{
                if attr == DONE || attr == NEXTSTEP </span><span class="cov0" title="0">{
                        attribute[attr] = val
                        isDoneOrNextStepPresent = true
                }</span>
        }

        <span class="cov0" title="0">if !isDoneOrNextStepPresent </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("property attributes does not contain either done or nextstep %v", attribute)
        }</span>

        <span class="cov0" title="0">return attribute, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package wfinstance

import (
        "errors"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/crux/server"
        "github.com/remiges-tech/logharbour/logharbour"
)

// Task request
type AddTaskRequest struct {
        Steps    []string
        Nextstep string
        Request  WFInstanceNewRequest
}

// getResponse request
type GetResponse struct {
        Subflow      map[string]string
        NextStep     string
        ResponseData []sqlc.Wfinstance
        Service      *service.Service
}

// To add multiple records in wfinstance table
func AddTasks(req AddTaskRequest, s *service.Service, c *gin.Context) (WFInstanceNewResponse, error) <span class="cov8" title="1">{
        var response WFInstanceNewResponse
        var parent pgtype.Int4
        subflow := make(map[string]string)

        lh := s.LogHarbour.WithClass("wfinstance")
        lh.Debug0().Log("inside addTasks()")

        query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                lh.Log("WFInstanceNew||addTasks()||error while getting query instance from service dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                return WFInstanceNewResponse{}, errors.New(INVALID_DATABASE_DEPENDENCY)
        }</span>

        <span class="cov8" title="1">if req.Request.Parent != nil </span><span class="cov0" title="0">{
                // convert int32 to pgtype.Int4
                parent = ConvertToPGType(*req.Request.Parent)
        }</span>

        // Add record in wfinstance table
        <span class="cov8" title="1">responseData, error := query.AddWFNewInstances(c, sqlc.AddWFNewInstancesParams{
                Entityid: req.Request.EntityID,
                Slice:    req.Request.Slice,
                App:      req.Request.App,
                Class:    req.Request.Entity[CLASS],
                Workflow: req.Request.Workflow,
                Step:     req.Steps,
                Nextstep: req.Nextstep,
                Parent:   parent,
        })
        if error != nil </span><span class="cov0" title="0">{
                lh.Error(error).Log("WFInstanceNew||addTasks()||error while adding Task steps in wfinstance table")
                return response, error
        }</span>

        // data change log
        <span class="cov8" title="1">for _, val := range responseData </span><span class="cov8" title="1">{
                dclog := lh.WithClass("wfinstance").WithInstanceId(strconv.Itoa(int(val.ID)))
                dclog.LogDataChange("created wfinstance ", logharbour.ChangeInfo{
                        Entity: "wfinstance",
                        Op:     "create",
                        Changes: []logharbour.ChangeDetail{
                                {
                                        Field:  "row",
                                        OldVal: nil,
                                        NewVal: val,
                                },
                        },
                })
        }</span>

        // To get workflow if step is present in stepworkflow table
        <span class="cov8" title="1">lh.Debug0().Log("WFInstanceNew||addTasks()||verifying whether step is workflow if it is, then append it to subflow")
        for _, step := range req.Steps </span><span class="cov8" title="1">{
                workflow, err := query.GetWorkflowNameForStep(c, step)

                if err != nil </span><span class="cov8" title="1">{
                        if err.Error() == "no rows in result set" </span><span class="cov8" title="1">{
                                continue</span> // If no workflow is found, continue to the next step
                        }
                }

                // Only proceed if err is nils
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        subflow[workflow.Step] = workflow.Workflow
                }</span>
        }

        // To get response
        <span class="cov8" title="1">getResponseData := GetResponse{
                Subflow:      subflow,
                NextStep:     req.Nextstep,
                ResponseData: responseData,
                Service:      s,
        }

        response = getResponse(getResponseData)
        lh.Debug0().LogActivity("response of addTask() :", response)
        return response, nil</span>
}

// response structure
func getResponse(r GetResponse) WFInstanceNewResponse <span class="cov8" title="1">{
        var tasks []map[string]int32
        var loggedDate pgtype.Timestamp
        var response WFInstanceNewResponse

        lh := r.Service.LogHarbour.WithClass("wfinstance")
        lh.Debug0().Log("Inside getResponse()")
        for _, val := range r.ResponseData </span><span class="cov8" title="1">{

                // adding tasks
                task := make(map[string]int32)
                task[val.Step] = val.ID
                tasks = append(tasks, task)
                //loggingdates
                loggedDate = val.Loggedat
        }</span>

        <span class="cov8" title="1">if len(tasks) &gt; 1 </span><span class="cov8" title="1">{
                // response for multiple task steps
                response = WFInstanceNewResponse{
                        Tasks:    tasks,
                        Nextstep: r.NextStep,
                        Loggedat: loggedDate,
                        Subflows: r.Subflow,
                }
        }</span> else<span class="cov8" title="1"> {
                //response for single task step
                response = WFInstanceNewResponse{
                        Tasks:    tasks,
                        Loggedat: loggedDate,
                        Subflows: r.Subflow,
                }
        }</span>
        <span class="cov8" title="1">return response</span>
}

// To convert int to pgtype.Int4
func ConvertToPGType(value int32) pgtype.Int4 <span class="cov0" title="0">{
        if value != 0 </span><span class="cov0" title="0">{
                return pgtype.Int4{
                        Int32: value,
                        Valid: true,
                }
        }</span>
        <span class="cov0" title="0">return pgtype.Int4{Int32: value, Valid: false}</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package wfinstance

import (
        "encoding/json"
        "errors"
        "fmt"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        crux "github.com/remiges-tech/crux/matching-engine"
        "github.com/remiges-tech/crux/server"
)

func validateWFInstanceNewReq(r WFInstanceNewRequest, realm string, s *service.Service, c *gin.Context) (bool, []wscutils.ErrorMessage) <span class="cov0" title="0">{
        lh := s.LogHarbour.WithClass("wfinstance")
        entity := r.Entity
        var errRes []wscutils.ErrorMessage

        lh.Debug0().Log("Inside ValidateWFInstaceNewReq()")
        query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                lh.Log("GetWFinstanceNew||validateWFInstanceNewReq()||error while getting query instance from service Dependencies")
                errRes := append(errRes, wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_DatabaseError, nil))
                return false, errRes
        }</span>
        // Validate request
        <span class="cov0" title="0">isValidReq, errAry := validateWorkflow(r, s, c, realm)
        if len(errAry) &gt; 0 || !isValidReq </span><span class="cov0" title="0">{
                lh.Debug0().LogActivity("GetWFinstanceNew||validateWFInstanceNewReq()||invalid request:", errAry)
                errRes = errAry
                return false, errRes
        }</span>

        // To verify whether entity has valid structure
        <span class="cov0" title="0">_, isKeyExist := entity[CLASS]

        if !(entity != nil &amp;&amp; isKeyExist) </span><span class="cov0" title="0">{
                lh.Debug0().Log("GetWFinstanceNew||validateWFInstanceNewReq()||entity does not match with standard structure")
                errRes = append(errRes, wscutils.BuildErrorMessage(server.MsgId_Invalid, server.ErrCode_Invalid_Entity, &amp;ENTITY))
                return false, errRes
        }</span>

        // To verify whether app,slice,class present in schema and get patternschema against it
        <span class="cov0" title="0">class := entity[CLASS]
        pattern, err := query.WfPatternSchemaGet(c, sqlc.WfPatternSchemaGetParams{
                Slice: r.Slice,
                Class: class,
                App:   r.App,
                Realm: realm,
        })
        if err != nil </span><span class="cov0" title="0">{
                lh.Error(err).Log("GetWFinstanceNew||validateWFInstanceNewReq()||failed to get schema pattern from DB")
                errRes = append(errRes, wscutils.BuildErrorMessage(server.MsgId_NoSchemaFound, server.ErrCode_NotFound, nil))
                return false, errRes
        }</span>

        // Unmarshalling byte data to schemapatten struct
        <span class="cov0" title="0">schemaPattern, err := byteToPatternSchema(pattern)
        lh.Debug0().LogActivity("GetWFinstanceNew||validateWFInstanceNewReq()||patternschema :", schemaPattern)
        if err != nil </span><span class="cov0" title="0">{
                lh.Debug0().LogActivity("GetWFinstanceNew||validateWFInstanceNewReq()|| error while converting byte patternschema to struct:", err)
                errRes = append(errRes, wscutils.BuildErrorMessage(server.MsgId_NoSchemaFound, server.ErrCode_Invalid_pattern_schema, nil))
                return false, errRes
        }</span>
        <span class="cov0" title="0">schema := crux.Schema_t{
                Class:         class,
                PatternSchema: *schemaPattern,
        }

        // Forming  requested entity  into proper Entity struct
        EntityStruct := getEntityStructure(r, realm)
        lh.Debug1().LogActivity("GetWFinstanceNew||validateWFInstanceNewReq()||entity stucture:", EntityStruct)

        //  To match entity against patternschema
        isValidEntity, err := ValidateEntity(EntityStruct, &amp;schema, s)
        if !isValidEntity || err != nil </span><span class="cov0" title="0">{
                lh.Debug0().LogActivity(" GetWFinstanceNew||validateWFInstanceNewReq()||error while validating entity against patternschema:", err)
                errRes = append(errRes, wscutils.BuildErrorMessage(server.MsgId_Invalid, server.ErrCode_Invalid_Entity, &amp;ENTITY))
                return false, errRes

        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// validate workflow
func validateWorkflow(r WFInstanceNewRequest, s *service.Service, c *gin.Context, realm string) (bool, []wscutils.ErrorMessage) <span class="cov0" title="0">{
        var errors []wscutils.ErrorMessage
        lh := s.LogHarbour.WithClass("wfinstance")
        entityClass := r.Entity[CLASS]

        lh.Debug0().Log("Inside validateWorkflow()")
        query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                lh.Debug0().Log("GetWFinstanceNew||validateWorkflow()||error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_DatabaseError))
                errors := append(errors, wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_DatabaseError, nil))
                return false, errors
        }</span>

        // The value of app specified in the request matches the app ID with which this workflow is associated

        <span class="cov0" title="0">lh.Debug0().Log("GetWFinstanceNew||validateWorkflow()||verifying whether app present in request is valid")
        applc := strings.ToLower(r.App)

        app, err := query.GetApp(c, sqlc.GetAppParams{
                Slice: r.Slice,
                App:   applc,
                Class: entityClass,
                Realm: realm,
        })

        if err != nil </span><span class="cov0" title="0">{
                lh.Error(err).Log("GetWFinstanceNew||validateWorkflow()||failed to get app from ruleset table")
                errors = append(errors, wscutils.BuildErrorMessage(server.MsgId_Invalid, server.ErrCode_Invalid_APP, &amp;APP, r.App))
        }</span>

        // The class of the workflow must match that of entity
        <span class="cov0" title="0">lh.Debug0().Log("GetWFinstanceNew||validateWorkflow()||verifying whether class present in request is valid")
        class, err := query.GetClass(c, sqlc.GetClassParams{
                Slice: r.Slice,
                App:   app,
                Class: entityClass,
                Realm: realm,
        })

        if err != nil </span><span class="cov0" title="0">{
                lh.Error(err).Log("GetWFinstanceNew||validateWorkflow()||failed to get class from ruleset table")
                errors = append(errors, wscutils.BuildErrorMessage(server.MsgId_Invalid, server.ErrCode_Invalid_Class, &amp;CLASS, entityClass))
        }</span>

        // The workflow named has is_active == true and internal == false

        // To get worflow active status
        <span class="cov0" title="0">lh.Debug0().Log("GetWFinstanceNew||validateWorkflow()||verifying whether workflow active status is valid")
        wfActiveStatus, err := query.GetWFActiveStatus(c, sqlc.GetWFActiveStatusParams{
                Slice:   r.Slice,
                App:     applc,
                Class:   class,
                Realm:   realm,
                Setname: r.Workflow,
        })

        if err != nil || !wfActiveStatus.Bool </span><span class="cov0" title="0">{
                lh.LogActivity("GetWFinstanceNew||validateWorkflow()||invalid workflow is_active status", err)
                errors = append(errors, wscutils.BuildErrorMessage(server.MsgId_Invalid, server.ErrCode_Invalid_workflow_active_status, &amp;WORKFLOW, fmt.Sprintf("%v", wfActiveStatus.Bool)))
        }</span>

        // To get worflow Internal status
        <span class="cov0" title="0">lh.Debug0().Log("GetWFinstanceNew||validateWorkflow()||verifying whether workflow internal status is valid")
        wfInternalStatus, err := query.GetWFInternalStatus(c, sqlc.GetWFInternalStatusParams{
                Slice:   r.Slice,
                App:     applc,
                Class:   class,
                Realm:   realm,
                Setname: r.Workflow,
        })

        if err != nil || wfInternalStatus </span><span class="cov0" title="0">{
                lh.LogActivity("GetWFinstanceNew||validateWorkflow()||invalid workflow is_internal status", err)
                errors = append(errors, wscutils.BuildErrorMessage(server.MsgId_Invalid, server.ErrCode_Invalid_workflow_Internal_status, &amp;WORKFLOW, fmt.Sprintf("%v", wfInternalStatus)))

        }</span>

        // There is no record in the wfinstance table with the same values for the tuple (slice,app,workflow,entityid)
        <span class="cov0" title="0">lh.Log("GetWFinstanceNew||validateWorkflow()||verifying whether record is already exist in wfinstance table")
        wfinstanceRecordCount, err := query.GetWFINstance(c, sqlc.GetWFINstanceParams{
                Slice:    r.Slice,
                App:      applc,
                Workflow: r.Workflow,
                Entityid: r.EntityID,
        })

        if err != nil || wfinstanceRecordCount &gt; 0 </span><span class="cov0" title="0">{
                lh.LogActivity("GetWFinstanceNew||validateWorkflow()||record already exist in wfinstance table ", err)
                errors = append(errors, wscutils.BuildErrorMessage(server.MsgId_AlreadyExist, server.ErrCode_AlreadyExist, &amp;ENTITYID, r.EntityID))
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return false, errors
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// validate entity
func ValidateEntity(e crux.Entity, ps *crux.Schema_t, s *service.Service) (bool, error) <span class="cov0" title="0">{

        lh := s.LogHarbour
        lh.Debug0().Log("Inside validateEntity()")

        // Check if the entity class matches the expected class from the schema
        if e.Class != ps.Class </span><span class="cov0" title="0">{
                lh.Debug0().Log("GetWFinstanceNew||validateEntity()||entity class does not match the expected class in the schema")
                return false, errors.New("Entity class does not match the expected class in the schema")
        }</span>

        // Validate attributes
        <span class="cov0" title="0">lh.Log("validating entity attributes")
        for name, val := range e.Attrs </span><span class="cov0" title="0">{
                t := getType(*ps, name)
                if t == "" </span><span class="cov0" title="0">{
                        lh.Debug0().LogActivity("GetWFinstanceNew||validateEntity()||schema does not contain attribute %v", name)
                        return false, fmt.Errorf("schema does not contain attribute %v", name)

                }</span>
                <span class="cov0" title="0">_, err := crux.ConvertEntityAttrVal(val, t)
                if err != nil </span><span class="cov0" title="0">{
                        lh.Debug0().LogActivity("GetWFinstanceNew||validateEntity()||attribute %v in entity has value of wrong type", name)
                        return false, fmt.Errorf("attribute %v in entity has value of wrong type", name)
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// To get type of request entity attributes
func getType(rs crux.Schema_t, name string) string <span class="cov0" title="0">{
        for _, as := range rs.PatternSchema </span><span class="cov0" title="0">{
                if as.Attr == name </span><span class="cov0" title="0">{
                        return as.ValType
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// To convert byte data to patternschema struct
func byteToPatternSchema(byteData []byte) (*[]crux.PatternSchema_t, error) <span class="cov0" title="0">{
        var ptternSchema *[]crux.PatternSchema_t
        err := json.Unmarshal(byteData, &amp;ptternSchema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return ptternSchema, nil</span>
}

// To convert request entity into proper Entity structure
func getEntityStructure(req WFInstanceNewRequest, realm string) crux.Entity <span class="cov0" title="0">{

        var attributes = make(map[string]string)
        for key, val := range req.Entity </span><span class="cov0" title="0">{
                if key != CLASS </span><span class="cov0" title="0">{
                        attributes[key] = val
                }</span>
        }
        <span class="cov0" title="0">entityStruct := crux.Entity{
                Realm: realm,
                App:   req.App,
                Slice: req.Slice,
                Class: req.Entity[CLASS],
                Attrs: attributes,
        }
        return entityStruct</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package wfinstance

import (
        "github.com/remiges-tech/crux/db/sqlc-gen"
)

// To Get ParentList from WFInstanceList data respone
func getParentList(data []sqlc.Wfinstance) []int32 <span class="cov0" title="0">{
        var parentsMap = make(map[int32]struct{})
        var parents []int32

        for _, val := range data </span><span class="cov0" title="0">{
                if val.Parent.Valid </span><span class="cov0" title="0">{
                        parentValue := val.Parent.Int32
                        _, exists := parentsMap[parentValue]
                        if !exists </span><span class="cov0" title="0">{
                                parents = append(parents, parentValue)
                                parentsMap[parentValue] = struct{}{}
                        }</span>
                }
        }
        <span class="cov0" title="0">return parents</span>

}
</pre>
		
		<pre class="file" id="file28" style="display: none">package server

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "os"
        "reflect"
        "slices"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/golang-jwt/jwt/v4"
        "github.com/remiges-tech/alya/router"
        "github.com/remiges-tech/alya/wscutils"

        crux "github.com/remiges-tech/crux/matching-engine"
        "github.com/remiges-tech/crux/types"
)

// CommonValidation is a generic function which setup standard validation utilizing
// validator package and Maps the errorVals based on the map parameter and
// return []errorVals
func CommonValidation(err validator.FieldError) []string <span class="cov0" title="0">{
        var vals []string
        switch err.Tag() </span>{
        case "required":<span class="cov0" title="0">
                vals = append(vals, "not_provided")</span>
        case "alpha":<span class="cov0" title="0">
                vals = append(vals, "only_alphabets_are_allowed")</span>
        case "gt":<span class="cov0" title="0">
                vals = append(vals, "must_be_greater_than_zero")</span>
        default:<span class="cov0" title="0">
                vals = append(vals, "not_valid_input")</span>
        }
        <span class="cov0" title="0">return vals</span>
}

func MarshalJson(data any) []byte <span class="cov0" title="0">{
        jsonData, err := json.Marshal(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("error marshaling")
        }</span>
        <span class="cov0" title="0">return jsonData</span>
}

func ReadJsonFromFile(filepath string) ([]byte, error) <span class="cov0" title="0">{
        // var err error
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("testFile path is not exist")
        }</span>
        <span class="cov0" title="0">defer file.Close()
        jsonData, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return jsonData, nil</span>
}

// to check given string is nil or not
func IsStringEmpty(s *string) bool <span class="cov0" title="0">{
        return s == nil || strings.TrimSpace(*s) == ""
}</span>

// to check if the user has "ruleset" rights for the given app
func HasRulesetRights(app string) bool <span class="cov0" title="0">{
        userRights := GetWorkflowsByRulesetRights()
        return slices.Contains(userRights, app)
}</span>

// to get workflows for all apps for which the user has "ruleset" rights
func GetWorkflowsByRulesetRights() []string <span class="cov0" title="0">{
        return []string{"retailBANK", "nedbank"}
}</span>

func Authz_check(op types.OpReq, trace bool) (bool, []string) <span class="cov8" title="1">{
        caplist := op.CapNeeded
        return true, caplist
}</span>

// To check whether requested user is exist in idshield and it is belong to valid realm
func IsValidUser(string, string) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>

// ExtractClaimFromJwt: this will extract the provided singleClaimName as key from the jwt token and return its value as a string
func ExtractClaimFromJwt(c *gin.Context, singleClaimName string) (string, error) <span class="cov0" title="0">{
        tokenString, err := router.ExtractToken(c.GetHeader("Authorization"))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid token payload")
        }</span>
        <span class="cov0" title="0">var name string
        token, _, err := new(jwt.Parser).ParseUnverified(tokenString, jwt.MapClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid token payload")
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                name = fmt.Sprint(claims[singleClaimName])
        }</span>

        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid token payload")
        }</span>

        <span class="cov0" title="0">return name, nil</span>
}

func ExtractRealmFromJwt(c *gin.Context) (string, error) <span class="cov0" title="0">{
        str, err := ExtractClaimFromJwt(c, "iss")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">parts := strings.Split(str, "/realms/")
        realm := parts[1]
        return realm, nil</span>
}

func ExtractUserNameFromJwt(c *gin.Context) (string, error) <span class="cov0" title="0">{
        return ExtractClaimFromJwt(c, "preferred_username")
}</span>

func HandleCruxError(errs []error) []wscutils.ErrorMessage <span class="cov0" title="0">{
        var validationErrors []wscutils.ErrorMessage
        for _, err := range errs </span><span class="cov0" title="0">{
                var cruxErr crux.CruxError
                fmt.Println("validationErrors", err)

                if errors.As(err, &amp;cruxErr) </span><span class="cov0" title="0">{
                        switch cruxErr.Keyword </span>{
                        case "Empty":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Empty, ErrCode_Empty, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "Invalid":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Invalid, ErrCode_Invalid, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "NotAllowed":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId__NotAllowed, ErrCode_NotAllowed, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "Required":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Invalid_Request, ErrCode_RequiredOneOf, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "NotExist":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_NotFound, ErrCode_NotFound, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "NotMatch":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgID_NotMatched, ErrCode_Not_Match, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        default:<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Invalid_Request, ErrCode_InvalidRequest, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        }
                }

        }
        <span class="cov0" title="0">return validationErrors</span>
}

func IsZeroOfUnderlyingType(x interface{}) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(x, reflect.Zero(reflect.TypeOf(x)).Interface())
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package testutils

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"

        "github.com/remiges-tech/alya/wscutils"
)

func MarshalJson(data any) []byte <span class="cov8" title="1">{
        jsonData, err := json.Marshal(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("error marshaling")
        }</span>
        <span class="cov8" title="1">return jsonData</span>
}

func ReadJsonFromFile(filepath string) ([]byte, error) <span class="cov0" title="0">{
        // var err error
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("testFile path is not exist")
        }</span>
        <span class="cov0" title="0">defer file.Close()
        jsonData, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return jsonData, nil</span>
}

type TestCasesStruct struct {
        Name             string
        RequestPayload   wscutils.Request
        PayloadFile      string
        ExpectedHttpCode int
        TestJsonFile     string
        ExpectedResult   *wscutils.Response
        Url              string
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package types

const (
        DevEnv           Environment = "dev_env"
        ProdEnv          Environment = "prod_env"
        UATEnv           Environment = "uat_env"
        RECORD_NOT_EXIST             = "record_does_not_exist"
        Op_FAILED                    = "Op_failed"
)

var APP, SLICE, CLASS, NAME string = "App", "Slice", "Class", "Name"

type Environment string

func (env Environment) IsValid() bool <span class="cov0" title="0">{
        switch env </span>{
        case DevEnv, ProdEnv, UATEnv:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

type OpReq struct {
        User      string   `json:"user"`
        CapNeeded []string `json:"capNeeded"`
        Scope     Scope    `json:"scope"`
        Limit     Limit    `json:"limit"`
}

type Scope map[string]interface{}
type Limit map[string]interface{}

type QualifiedCap struct {
        Id    string `json:"id"`
        Cap   string `json:"cap"`
        Scope Scope  `json:"scope"`
        Limit Limit  `json:"limit"`
}

type Capabilities struct {
        Name          string         `json:"name"` //either user name or group name
        QualifiedCaps []QualifiedCap `json:"qualifiedCaps"`
}

type Attribute struct {
        Name      string   `json:"name" validate:"required"`
        ShortDesc string   `json:"shortdesc" validate:"required"`
        LongDesc  string   `json:"longdesc" validate:"required"`
        ValType   string   `json:"valtype" validate:"required"`
        Vals      []string `json:"vals,omitempty"`
        Enumdesc  []string `json:"enumdesc,omitempty"`
        ValMax    *int32   `json:"valmax,omitempty"`
        ValMin    *int32   `json:"valmin,omitempty"`
        LenMax    *int32   `json:"lenmax,omitempty"`
        LenMin    *int32   `json:"lenmin,omitempty"`
}

type PatternSchema struct {
        Class string      `json:"class" validate:"required,lowercase"`
        Attr  []Attribute `json:"attr" validate:"required,dive"`
}

type ActionSchema struct {
        Class      string   `json:"class" validate:"required,lowercase"`
        Tasks      []string `json:"tasks" validate:"required"`
        Properties []string `json:"properties" validate:"required"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
